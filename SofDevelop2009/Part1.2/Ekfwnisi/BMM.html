<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html class="pageview"><head>







<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- base -->
<style type="text/css">
  

/* default css */

table {
  font-size: 1em;
  line-height: inherit;
  border-collapse: collapse;
}


tr {
  
  text-align: left;
  
}


div, address, ol, ul, li, option, select {
  margin-top: 0px;
  margin-bottom: 0px;
}

p {
  margin: 0px;
}


pre {
  font-family: Courier New;
  white-space: pre-wrap;
  margin:0;
}

body {
  margin: 6px;
  padding: 0px;
  font-family: Verdana, sans-serif;
  font-size: 10pt;
  background-color: #ffffff;
}


img {
  -moz-force-broken-image-icon: 1;
}

@media screen {
  html.pageview {
    background-color: #f3f3f3 !important;
  }

  

  body {
    min-height: 1100px;
    
    counter-reset: __goog_page__;
  }
  * html body {
    height: 1100px;
  }
  .pageview body {
    border-top: 1px solid #ccc;
    border-left: 1px solid #ccc;
    border-right: 2px solid #bbb;
    border-bottom: 2px solid #bbb;
    width: 648px !important;
    margin: 15px auto 25px;
    padding: 40px 50px;
  }
  /* IE6 */
  * html {
    overflow-y: scroll;
  }
  * html.pageview body {
    overflow-x: auto;
  }
  /* Prevent repaint errors when scrolling in Safari. This "Star-7" css hack
     targets Safari 3.1, but not WebKit nightlies and presumably Safari 4.
     That's OK because this bug is fixed in WebKit nightlies/Safari 4 :-). */
  html*#wys_frame::before {
    content: '\A0';
    position: fixed;
    overflow: hidden;
    width: 0;
    height: 0;
    top: 0;
    left: 0;
  }
  
  

  
    .writely-callout-data {
      display: none;
      *display: inline-block;
      *width: 0;
      *height: 0;
      *overflow: hidden;
    }
    .writely-footnote-marker {
      background-image: url('MISSING');
      background-color: transparent;
      background-repeat: no-repeat;
      width: 7px;
      overflow: hidden;
      height: 16px;
      vertical-align: top;

      
      -moz-user-select: none;
    }
    .editor .writely-footnote-marker {
      cursor: move;
    }
    .writely-footnote-marker-highlight {
      background-position: -15px 0;
      -moz-user-select: text;
    }
    .writely-footnote-hide-selection ::-moz-selection, .writely-footnote-hide-selection::-moz-selection {
      background: transparent;
    }
    .writely-footnote-hide-selection ::selection, .writely-footnote-hide-selection::selection {
      background: transparent;
    }
    .writely-footnote-hide-selection {
      cursor: move;
    }

    
    .editor .writely-comment-yellow {
      background-color: #FF9;
      background-position: -240px 0;
    }
    .editor .writely-comment-yellow-hover {
      background-color: #FF0;
      background-position: -224px 0;
    }
    .editor .writely-comment-blue {
      background-color: #C0D3FF;
      background-position: -16px 0;
    }
    .editor .writely-comment-blue-hover {
      background-color: #6292FE;
      background-position: 0 0;
    }
    .editor .writely-comment-orange {
      background-color: #FFDEAD;
      background-position: -80px 0;
    }
    .editor .writely-comment-orange-hover {
      background-color: #F90;
      background-position: -64px 0;
    }
    .editor .writely-comment-green {
      background-color: #99FBB3;
      background-position: -48px 0;
    }
    .editor .writely-comment-green-hover {
      background-color: #00F442;
      background-position: -32px 0;
    }
    .editor .writely-comment-cyan {
      background-color: #CFF;
      background-position: -208px 0;
    }
    .editor .writely-comment-cyan-hover {
      background-color: #0FF;
      background-position: -192px 0;
    }
    .editor .writely-comment-purple {
      background-color: #EBCCFF;
      background-position: -144px 0;
    }
    .editor .writely-comment-purple-hover {
      background-color: #90F;
      background-position: -128px 0;
    }
    .editor .writely-comment-magenta {
      background-color: #FCF;
      background-position: -112px 0;
    }
    .editor .writely-comment-magenta-hover {
      background-color: #F0F;
      background-position: -96px 0;
    }
    .editor .writely-comment-red {
      background-color: #FFCACA;
      background-position: -176px 0;
    }
    .editor .writely-comment-red-hover {
      background-color: #FF7A7A;
      background-position: -160px 0;
    }

    .editor .writely-comment-marker {
      background-image: url('MISSING');
      background-color: transparent;
      padding-right: 11px;
      background-repeat: no-repeat;
      width: 16px;
      height: 16px;
      -moz-user-select: none;
    }

    .editor .writely-comment-hidden {
      padding: 0;
      background: none;
    }
    .editor .writely-comment-marker-hidden {
      background: none;
      padding: 0;
      width: 0;
    }
    .editor .writely-comment-none {
      opacity: .2;
      filter:progid:DXImageTransform.Microsoft.Alpha(opacity=20);
      -moz-opacity: .2;
    }
    .editor .writely-comment-none-hover {
      opacity: .2;
      filter:progid:DXImageTransform.Microsoft.Alpha(opacity=20);
      -moz-opacity: .2;
    }
  


  
  .br_fix span+br:not(:-moz-last-node) {
    
    position:relative;
    
    left: -1ex
    
  }

  
  #cb-p-tgt {
    font-size: 8pt;
    padding: .4em;
    background-color: #ddd;
    color: #333;
  }
  #cb-p-tgt-can {
    text-decoration: underline;
    color: #36c;
    font-weight: bold;
    margin-left: 2em;
  }
  #cb-p-tgt .spin {
    width: 16px;
    height: 16px;
    background: url(//ssl.gstatic.com/docs/clipboard/spin_16o.gif) no-repeat;
  }
}

h6 { font-size: 8pt }
h5 { font-size: 8pt }
h4 { font-size: 10pt }
h3 { font-size: 12pt }
h2 { font-size: 14pt }
h1 { font-size: 18pt }

blockquote {padding: 10px; border: 1px #DDD dashed }

.webkit-indent-blockquote { border: none; }

a img {border: 0}

.pb {
  border-width: 0;
  page-break-after: always;
  /* We don't want this to be resizeable, so enforce a width and height
     using !important */
  height: 1px !important;
  width: 100% !important;
}

.editor .pb {
  border-top: 1px dashed #C0C0C0;
  border-bottom: 1px dashed #C0C0C0;
}

div.google_header, div.google_footer {
  position: relative;
  margin-top: 1em;
  margin-bottom: 1em;
}


/* Table of contents */
.editor div.writely-toc {
  background-color: #f3f3f3;
  border: 1px solid #ccc;
}
.writely-toc > ol {
  padding-left: 3em;
  font-weight: bold;
}
ol.writely-toc-subheading {
  padding-left: 1em;
  font-weight: normal;
}
/* IE6 only */
* html writely-toc ol {
  list-style-position: inside;
}
.writely-toc-none {
  list-style-type: none;
}
.writely-toc-decimal {
  list-style-type: decimal;
}
.writely-toc-upper-alpha {
  list-style-type: upper-alpha;
}
.writely-toc-lower-alpha {
  list-style-type: lower-alpha;
}
.writely-toc-upper-roman {
  list-style-type: upper-roman;
}
.writely-toc-lower-roman {
  list-style-type: lower-roman;
}
.writely-toc-disc {
  list-style-type: disc;
}

/* Ordered lists converted to numbered lists can preserve ordered types, and
   vice versa. This is confusing, so disallow it */
ul[type="i"], ul[type="I"], ul[type="1"], ul[type="a"], ul[type="A"] {
  list-style-type: disc;
}

ol[type="disc"], ol[type="circle"], ol[type="square"] {
  list-style-type: decimal;
}

/* end default css */


  /* default print css */
  
  @media print {
    body {
      padding: 0;
      margin: 0;
    }

    div.google_header, div.google_footer {
      display: block;
      min-height: 0;
      border: none;
    }

    div.google_header {
      flow: static(header);
    }

    /* used to insert page numbers */
    div.google_header::before, div.google_footer::before {
      position: absolute;
      top: 0;
    }

    div.google_footer {
      flow: static(footer);
    }

    /* always consider this element at the start of the doc */
    div#google_footer {
      flow: static(footer, start);
    }

    span.google_pagenumber {
      content: counter(page);
    }

    span.google_pagecount {
      content: counter(pages);
    }

    .endnotes {
      page: endnote;
    }

    /* MLA specifies that endnotes title should be 1" margin from the top of the page. */
    @page endnote {
      margin-top: 1in;
    }

    callout.google_footnote {
      
      display: prince-footnote;
      footnote-style-position: inside;
      /* These styles keep the footnote from taking on the style of the text
         surrounding the footnote marker. They can be overridden in the
         document CSS. */
      color: #000;
      font-family: Verdana;
      font-size: 10.0pt;
      font-weight: normal;
    }

    /* Table of contents */
    #WritelyTableOfContents a::after {
      content: leader('.') target-counter(attr(href), page);
    }

    #WritelyTableOfContents a {
      text-decoration: none;
      color: black;
    }
  }

  @page {
    @top {
      content: flow(header);
    }
    @bottom {
      content: flow(footer);
    }
    @footnotes {
      border-top: solid black thin;
      padding-top: 8pt;
    }
  }
  /* end default print css */


/* custom css */


/* end custom css */

/* ui edited css */

body {
  font-family: Verdana;
  
  font-size: 10.0pt;
  line-height: normal;
  background-color: #ffffff;
}
/* end ui edited css */


/* editor CSS */
.editor a:visited {color: #551A8B}
.editor table.zeroBorder {border: 1px dotted gray}
.editor table.zeroBorder td {border: 1px dotted gray}
.editor table.zeroBorder th {border: 1px dotted gray}


.editor div.google_header, .editor div.google_footer {
  border: 2px #DDDDDD dashed;
  position: static;
  width: 100%;
  min-height: 2em;
}

.editor .misspell {background-color: yellow}

.editor .writely-comment {
  font-size: 9pt;
  line-height: 1.4;
  padding: 1px;
  border: 1px dashed #C0C0C0
}


/* end editor CSS */

</style>

  
  <title>K25 Ανάπτυξη Λογισμικού - BMM</title>

</head><body>
    
    
    
<div style="text-align: center;">
  <h1>
    Πληροφορική &amp; Τηλεπικοινωνίες K25<br>
    Ανάπτυξη Λογισμικού<br>
    Χειμερινό Εξάμηνο 2009-10<br>
    Καθηγητής Γιάννης Ιωαννίδης
  </h1>
</div>
<p>
</p>
<hr> <center>
<h1>
  Μέρος 1ο, 2/3: Μονάδα διαχείρισης ενδιάμεσης μνήμης<br>
</h1>
<h3>
  (Ημερομηνία Παράδοσης: Τρίτη, 3/11/2009, 17:00)
</h3>
</center>
<div style="text-align: left;">
  <br>
  <div style="text-align: center;">
    <img src="BMM_files/drawing_snTqL4lRg5wNfLcR_A-TMdA_104.png"><br>
  </div>
  <br>
  <h2>
    Εισαγωγή
  </h2>
Η μονάδα διαχείρισης ενδιάμεσης μνήμης υλοποιεί μια Διεπαφή
Προγραμματισμού Εφαρμογών με σκοπό να παρέχει την πλήρη λειτουργικότητα
που γίνεται στην ενδιάμεση μνήμη του Συστήματος Διαχείρισης Βάσεων
Δεδομένων (ΣΔΒΔ). Μονάδα διαχείρισης είναι το μπλοκ (block) και η
διεπαφή περιλαμβάνει συναρτήσεις για διάβασμα συγκεκριμένου block,
"ξεκάρφωμα" block, καθαρισμό της ενδιάμεσης μνήμης κ.λπ.<br>
  <br>
Οι ρουτίνες της συγκεκριμένης διεπαφής περιγράφονται παρακάτω. Τα
ονόματα όλων των ρουτινών αρχίζουν με το πρόθεμα BMM, ώστε να
υποδεικνύουν το γεγονός ότι πρόκειται για υλοποίηση αρχείου ενδιάμεσης
μνήμης (BMM = Buffer Management Module). H γλώσσα υλοποίησης είναι η C.<br>
</div>
<div>
  <br> Οι περισσότερες ρουτίνες επιστρέφουν έναν ακέραιο αριθμό,
όπου αρνητική τιμή σημαίνει ότι έχει προκύψει κάποιο σφάλμα. Υπάρχουν
διάφοροι κωδικοί σφαλμάτων στο επίπεδο BM, οι οποίοι περιγράφονται στο
τέλος της εκφώνησης.<br>
  <br>
Το συγκεκριμένο επίπεδο είναι υπεύθυνο και για τον αλγόριθμο
αντικατάστασης block με τον οποίο αυτά ανανεώνονται όταν γεμίσει η
ενδιάμεση μνήμη. Στη δική μας περίπτωση, η αντικατάσταση γίνεται μέσω
LRU (Least Recently Used - Λιγότερο Πρόσφατα Χρησιμοποιημένο), που
αφορά μόνο τα μη-καρφωμένα blocks της μνήμης. Αν κατά τη διάρκεια
αντικατάστασης σελίδων, πρέπει να φύγει ένα block που έχει αλλαχθεί από
τη στιγμή που το φέραμε στη μνήμη, τότε αυτό θα πρέπει να γραφτεί στο
δίσκο και μετά να αντικατασταθεί. Ένα block που παραμένει καρφωμένο στη
μνήμη δε μπορεί να αντικατασταθεί.<br>
  <br>
Τα μπλοκ στην ενδιάμεση μνήμη αναγνωρίζονται από το όνομα του αρχείου
από το οποίο προέρχονται και έναν ακέραιο "αριθμό block", ο οποίος έχει
άμεση σχέση με τη νοητή σειρά του στο αρχείο.<br>
  <br>
  <div style="text-align: center;">
    <img src="BMM_files/drawing_sDAsW2JDui1vk8c4opAmWeA_178.png"><br>
    <br>
  </div>
Επίσης, κάθε block είναι καρφωμένο στη μνήμη από μια σειρά αρχείων, που
είναι τα αρχεία εκείνα που έχουν ζητήσει το block αυτό και δεν το έχουν
"ξεκαρφώσει". Συνεπώς, το ίδιο block ενός αρχείου δεν υπάρχει
περισσότερες από μία φορά στην ενδιάμεση μνήμη, αλλά μπορεί να έχει
ζητηθεί από περισσότερα από ένα ανοιχτά αρχεία.<br>
  <br>
  Τέλος, το μέγεθος της ενδιάμεσης μνήμης προσδιορίζεται από τη σταθερά <i>BF_BUFFER_SIZE</i>= 20 μπλοκ, ενώ το μέγεθος ενός μπλοκ προσδιορίζεται από τη σταθερά <i>BF_BLOCK_SIZE</i>= 1024 bytes.<br>
  <br>
  Η εργασία αυτή είναι ατομική.<br>
  <br>
  <hr><font size="4"><b>Ρουτίνες Υλοποίησης Μονάδας Ενδιάμεσης Μνήμης.<br>
  </b></font><font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><font size="3"><b><br>
  </b><font size="4">BMM_Init()</font></font></span><span style="background-color: rgb(255, 255, 255);"><br>
  <br>
  void BMM_Init()<br>
  <br>
  </span></font>Η
ρουτίνα αυτή χρησιμοποιείται για να αρχικοποιήσετε τις όποιες καθολικές
(global) εσωτερικές δομές δεδομένων αποφασίσετε ότι χρειάζεστε. Δεν
έχει καμία παράμετρο εισόδου και δεν παράγει καμία έξοδο. <font style="background-color: rgb(244, 204, 204);" face="Courier New"><br style="background-color: rgb(255, 255, 255);">
  <span style="background-color: rgb(255, 255, 255);"><br>
  </span></font><font style="background-color: rgb(244, 204, 204);" size="4" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  BMM_GetBlock()</span></font><br>
  <font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  int BMM_GetBlock(<br>
  &nbsp;&nbsp; &nbsp;fileInfo_t finfo,<br>
  &nbsp;&nbsp; &nbsp;int blockNum,<br>
  &nbsp;&nbsp; &nbsp;char** blockBuf);</span><br style="background-color: rgb(255, 255, 255);">
  <span style="background-color: rgb(255, 255, 255);"><br>
  </span></font>Η
ρουτίνα αυτή διαβάζει στην ενδιάμεση μνήμη το μπλοκ με αναγνωριστικό
blockNum του αρχείου που προσδιορίζεται από το finfo και μετά βάζει τον
δείκτη <i>*blockBuf</i> να δείχνει σ' αυτό.<br>
  <font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  </span></font><font style="background-color: rgb(244, 204, 204);" size="4" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  BMM_AllocBlock()</span></font><br>
  <font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  int BMM_AllocBlock(<br>
  &nbsp;&nbsp; &nbsp;fileInfo_t finfo,<br>
  &nbsp;&nbsp; &nbsp;int blockNum,<br>
  &nbsp;&nbsp; &nbsp;char** blockBuf);</span><br style="background-color: rgb(255, 255, 255);">
  <span style="background-color: rgb(255, 255, 255);"><br>
  </span></font>Η
ρουτίνα αυτή προσθέτει ένα νέο άδειο μπλοκ στην ενδιάμεση μνήμη για το
αρχείο που προσδιορίζεται από το finfo. Το άδειο block αντιστοιχεί στο
νοητό bock υπ' αριθμό blockNum και βάζει τον δείκτη <i>*blockBuf</i> να δείχνει σε αντίστοιχο χώρο στην ενδιάμεση μνήμη.<br>
  <font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  <br>
  </span></font><font style="background-color: rgb(244, 204, 204);" size="4" face="Courier New"><span style="background-color: rgb(255, 255, 255);">BMM_UnpinBlock()</span></font><font size="4"><br>
  </font><font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  int BMM_UnpinBlock(<br>
  &nbsp;&nbsp; &nbsp;fileInfo_t finfo,<br>
  &nbsp;&nbsp; &nbsp;int blockNum,<br>
  &nbsp;&nbsp; &nbsp;BOOLEAN dirty);</span><br style="background-color: rgb(255, 255, 255);">
  <span style="background-color: rgb(255, 255, 255);"><br>
  </span></font>Η ρουτίνα αυτή ειδοποιεί ότι το μπλοκ με αριθμό <i>blockNum</i>
του αρχείου που προσδιορίζεται από το finfo δεν χρειάζεται πια στην
ενδιάμεση μνήμη και μπορεί να "ξεκαρφωθεί''. Η παράμετρος dirty είναι
ίση με <i>TRUE</i> εάν το μπλοκ έχει αλλάξει στην ενδιάμεση μνήμη από
τη στιγμή που "καρφώθηκε" εκεί (οπότε σε περίπτωση αντικατάστασής του
πρέπει πρώτα να γραφτεί στη θέση του στο δίσκο), ειδ' αλλοιώς είναι ίση
με <i>FALSE</i>. Η ρουτίνα επιστρέφει BFE_OK εάν επιτύχει ή κάποιον κωδικό σφάλματος εάν κάτι δεν λειτουργήσει όπως πρέπει.<br>
  <font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  <br>
  </span></font><font style="background-color: rgb(244, 204, 204);" size="4" face="Courier New"><span style="background-color: rgb(255, 255, 255);">BMM_DisposeBlock()</span></font><br>
  <font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  int BMM_DisposeBlock(<br>
  &nbsp;&nbsp; &nbsp;fileInfo_t finfo,<br>
  &nbsp;&nbsp; &nbsp;int blockNum);</span><br style="background-color: rgb(255, 255, 255);">
  <br>
  </font>Η ρουτίνα αυτή επιστρέφει προς ανακύκλωση το μπλοκ με αριθμό <i>blockNum</i>
του αρχείου που προσδιορίζεται από το finfo. To μπλοκ δεν μπορεί να
είναι ``καρφωμένο'' στην ενδιάμεση μνήμη. Η ρουτίνα επιστρέφει BFE_OK
εάν επιτύχει ή κάποιον κωδικό σφάλματος εάν κάτι δεν λειτουργήσει όπως
πρέπει.<br>
  <font style="background-color: rgb(244, 204, 204);" face="Courier New"><br style="background-color: rgb(255, 255, 255);">
  <span style="background-color: rgb(255, 255, 255);"><br>
  </span></font><font style="background-color: rgb(244, 204, 204);" size="4" face="Courier New"><span style="background-color: rgb(255, 255, 255);">BMM_Flush()</span></font><font size="4"><br>
  </font><font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  int BMM_Flush(<br>
  &nbsp;&nbsp; &nbsp;fileInfo_t finfo);</span><br style="background-color: rgb(255, 255, 255);">
  <span style="background-color: rgb(255, 255, 255);"><br>
  <span style="background-color: rgb(255, 255, 255); font-family: Verdana;">Η ρουτίνα αυτή γράφει στον δίσκο </span></span></font><font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><span style="background-color: rgb(255, 255, 255); font-family: Verdana;">τα "βρώμικα"</span></span></font><font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><span style="background-color: rgb(255, 255, 255); font-family: Verdana;"> μπλοκ </span></span></font><span style="background-color: rgb(255, 255, 255); font-family: Verdana;">του αρχείου που προσδιορίζεται από το finfo</span><font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"> <span style="font-family: Verdana;">και δεν χρησιμοποιούνται από κάποιο άνοιγμα. </span><br style="background-color: rgb(255, 255, 255);">
  <br>
  <br>
  </span></font><font style="background-color: rgb(244, 204, 204);" size="4" face="Courier New"><span style="background-color: rgb(255, 255, 255);">BMM_Clear()</span></font><br>
  <font style="background-color: rgb(244, 204, 204);" face="Courier New"><span style="background-color: rgb(255, 255, 255);"><br>
  int BMM_Clear(<br>
  &nbsp;&nbsp; &nbsp;char* fileName);</span><br>
  <br>
  <span style="background-color: rgb(255, 255, 255); font-family: Verdana;">Η ρουτίνα αυτή "καθαρίζει" την ενδιάμεση μνήμη από τυχόν μπλοκ του αρχείου με όνομα fileName.</span><br style="background-color: rgb(255, 255, 255); font-family: Verdana;">
  </font><br>
  <br>
  <b><font size="4">Κωδικοί λαθών</font></b><br>
  <br>
#define BFE_OK&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;/* OK */<br>
#define BFE_NOMEM&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Δεν υπάρχει διαθέσιμη
μνήμη */<br>
#define BFE_CANNOTOPENFILE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Αδύνατο το
άνοιγμα του αρχείου */<br>
#define
BFE_CANNOTCLOSEFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Αδύνατο το κλείσιμο του αρχείου */<br>
#define BFE_CANNOTCREATEFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Αδύνατη η δημιουργία του αρχείου */<br>
#define
BFE_INCOMPLETEREAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Ημιτελές διάβασμα */<br>
#define
BFE_INCOMPLETEWRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Ημιτελές γράψιμο */<br>
#define
BFE_FILEEXISTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Το αρχείο υπάρχει ήδη */<br>
#define
BFE_NOBUF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Έλλειψη χώρου στην ενδιάμεση
μνήμη */<br>
#define
BFE_FILEOPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-10&nbsp;&nbsp;&nbsp;&nbsp; /* Το αρχείο είναι ήδη ανοιχτό */<br>
#define
BFE_FD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-11&nbsp;&nbsp;&nbsp;&nbsp; /* Λανθασμένο αναγνωριστικό αρχείου */<br>
#define
BFE_FILENOTEXISTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-12&nbsp;&nbsp;&nbsp; /* Το αρχείο δεν υπάρχει */<br>
#define
BFE_FTABFULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-13&nbsp;&nbsp;&nbsp; /* Λίστα ανοιχτών αρχείων πλήρης */<br>
#define
BFE_HEADOVERFLOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-14&nbsp;&nbsp;&nbsp; /* Λανθασμένος αριθμός&nbsp; */<br>
#define
BFE_BLOCKFIXED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-15&nbsp;&nbsp;&nbsp; /* Μπλοκ ήδη "καρφωμένο" στη μνήμη */<br>
#define
BFE_BLOCKUNFIXED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-16&nbsp;&nbsp;&nbsp; /* Μπλοκ ήδη ξεκαρφωμένο */<br>
#define
BFE_EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-17&nbsp;&nbsp;&nbsp; /* Τέλος αρχείου */<br>
  #define BFE_FILEHASFIXEDBLOCKS&nbsp;&nbsp;&nbsp; -18&nbsp;&nbsp;&nbsp; /* Το αρχείο έχει καρφωμένα block */<br>
#define
BFE_BLOCKFREE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-19&nbsp;&nbsp; /* Μπλοκ ήδη διαθέσιμο προς ανακύκλωση */<br>
#define
BFE_BLOCKINBUF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-20&nbsp;&nbsp; /* Μπλοκ ήδη στη μνήμη */<br>
#define
BFE_BLOCKNOTINBUF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-21&nbsp;&nbsp; /* Μπλοκ όχι στη μνήμη */<br>
#define
BFE_INVALIDBLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-22&nbsp;&nbsp; /* Λανθασμένος κωδικός block */<br>
  #define BFE_CANNOTDESTROYFILE&nbsp;&nbsp; &nbsp; -23&nbsp;&nbsp; /* Αδύνατη η καταστροφή του αρχείου */<br>
  <br>
#define
BF_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Μέγεθος της ενδιάμεσης μνήμης
σε block */<br>
#define
MAXOPENFILES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Μέγιστο πλήθος ανοιχτών
αρχείων */<br>
#define
BF_BLOCK_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1024&nbsp;&nbsp;&nbsp; /* Μέγεθος ενός block σε bytes */<br>
#define
MAX_BLOCKS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
8192&nbsp;&nbsp;&nbsp;&nbsp; /* Μέγιστο πλήθος από διαθέσιμα block ανά
αρχείο */<br>
#define
MAX_FILE_NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
256&nbsp;&nbsp;&nbsp;&nbsp; /* Μέγιστο μέγεθος για όνομα ενός αρχείου */<br>
  <br>
  <h2>
    Σχόλια για την Υλοποίηση
  </h2>
  <span style="background-color: rgb(255, 255, 255);">Θα
πρέπει να ορίσετε κάποιες δομές (π.χ., απλούς πίνακες ή πίνακες
κατακερματισμού) στο πρόγραμμά σας. Σε αυτές θα κρατάτε όποια στοιχεία
κρίνετε χρήσιμα για τα μπλοκ της ενδιάμεσης μνήμης και των εκάστοτε
περιεχομένων τους. Κάθε (μη κενή) θέση του πίνακα θα περιέχει ή θα
δείχνει προς τα στοιχεία που αντιστοιχούν σε ένα μπλοκ. Ανάμεσα στα
στοιχεία που θα κρατάτε πρέπει να είναι και οι πληροφορίες που
χρειάζεστε για να εφαρμόσετε σωστά την πολιτική αντικατάστασης μπλοκ
στην ενδιάμεση μνήμη (LRU).</span> Να επισημάνουμε ότι τα παραπάνω
είναι οδηγίες αλλά όχι υποχρεωτικές. Εσείς μπορείτε να υλοποιήσετε τα
πράγματα διαφορετικά αν θέλετε. Οι διεπαφές των ρουτινών και η
λειτουργικότητά τους είναι τα μόνα πράγματα που δεν μπορείτε να
αλλάξετε.<br>
  <span style="background-color: rgb(255, 255, 255);">Κάθε
συνάρτηση πρέπει να θέτει μία καθολική μεταβλητή του προγράμματος
BF_errno στον κατάλληλο κωδικό σφάλματος, ανάλογα με την έκβασή της
εκτέλεσής της (της συνάρτησης). Το σφάλμα αυτό επιστρέφεται στα πιο
πάνω επίπεδα για την κατάλληλη διαχείριση τους.</span><br>
  <hr>
  <h2>
    <img src="BMM_files/MISSING.html"> Σχολιασμός, Έλεγχος Σφαλμάτων, και Γενική Μορφοποίηση
  </h2>
Όπως πάντοτε, αναμένεται καλός σχολιασμός του προγράμματος, και
εσωτερικός (ανάμεσα στις γραμμές κώδικα) και εξωτερικός (στην αρχή κάθε
ρουτίνας). Ένας γενικός κανόνας είναι να σχολιάζετε τα προγράμματά σας
σαν να πρόκειται να τα δώσετε σε κάποιον άλλον ο οποίος θα τα
επεκτείνει και ο οποίος δεν έχει ιδέα για το τι κάνατε όταν τα γράφατε
(και δεν μπορεί ούτε να σας βρει να σας ρωτήσει). <p> Επίσης, θα πρέπει να ελέγχετε για διάφορα σφάλματα που μπορούν
να προκύψουν και να βεβαιωθειτε ότι ο κώδικάς σας τερματίζει ομαλά, με
μηνύματα που έχουν νόημα, σε όλες τις εισόδους που ικανοποιούν την
παραπάνω περιγραφή. </p>
  <hr>
  <h2>
    <img src="BMM_files/MISSING.html">Διαδικαστικές Λεπτομέρειες
  </h2>
Το τί ακριβώς θα παραδώσετε, πού θα βρείτε τα αρχεία με τα οποία θα
ελέγξετε τελικά το πρόγραμμά σας, κτλ., θα ανακοινωθεί σύντομα. <p> Τα προγράμματά σας θα πρέπει να δουλεύουν στα μηχανήματα του
τμήματος (είτε στα sun (Linux) είτε στα pc (Windows)) ώστε να μπορούν
να ελεγχθούν. Ακόμη και αν δουλέψετε σε δικούς σας υπολογιστές θα
πρέπει να βεβαιωθείτε ότι το τελικό αποτέλεσμα δουλεύει και εδώ τοπικά.
Η έκδοση της C που θα χρησιμοποιήσετε πρέπει να έχει ακέραιους των 4
bytes και να επιτρέπει αλλαγή ερμηνείας τύπου δεδομένων (type casting).
</p>
  <hr size="2">
  <p>
  </p>
</div>
<br></body></html>