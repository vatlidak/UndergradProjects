<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html class="pageview"><head>







<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- base -->
<style type="text/css">
  

/* default css */

table {
  font-size: 1em;
  line-height: inherit;
  border-collapse: collapse;
}


tr {
  
  text-align: left;
  
}


div, address, ol, ul, li, option, select {
  margin-top: 0px;
  margin-bottom: 0px;
}

p {
  margin: 0px;
}


pre {
  font-family: Courier New;
  white-space: pre-wrap;
  margin:0;
}

body {
  margin: 6px;
  padding: 0px;
  font-family: Verdana, sans-serif;
  font-size: 10pt;
  background-color: #ffffff;
}


img {
  -moz-force-broken-image-icon: 1;
}

@media screen {
  html.pageview {
    background-color: #f3f3f3 !important;
  }

  

  body {
    min-height: 1100px;
    
    counter-reset: __goog_page__;
  }
  * html body {
    height: 1100px;
  }
  .pageview body {
    border-top: 1px solid #ccc;
    border-left: 1px solid #ccc;
    border-right: 2px solid #bbb;
    border-bottom: 2px solid #bbb;
    width: 648px !important;
    margin: 15px auto 25px;
    padding: 40px 50px;
  }
  /* IE6 */
  * html {
    overflow-y: scroll;
  }
  * html.pageview body {
    overflow-x: auto;
  }
  /* Prevent repaint errors when scrolling in Safari. This "Star-7" css hack
     targets Safari 3.1, but not WebKit nightlies and presumably Safari 4.
     That's OK because this bug is fixed in WebKit nightlies/Safari 4 :-). */
  html*#wys_frame::before {
    content: '\A0';
    position: fixed;
    overflow: hidden;
    width: 0;
    height: 0;
    top: 0;
    left: 0;
  }
  
  

  
    .writely-callout-data {
      display: none;
      *display: inline-block;
      *width: 0;
      *height: 0;
      *overflow: hidden;
    }
    .writely-footnote-marker {
      background-image: url('MISSING');
      background-color: transparent;
      background-repeat: no-repeat;
      width: 7px;
      overflow: hidden;
      height: 16px;
      vertical-align: top;

      
      -moz-user-select: none;
    }
    .editor .writely-footnote-marker {
      cursor: move;
    }
    .writely-footnote-marker-highlight {
      background-position: -15px 0;
      -moz-user-select: text;
    }
    .writely-footnote-hide-selection ::-moz-selection, .writely-footnote-hide-selection::-moz-selection {
      background: transparent;
    }
    .writely-footnote-hide-selection ::selection, .writely-footnote-hide-selection::selection {
      background: transparent;
    }
    .writely-footnote-hide-selection {
      cursor: move;
    }

    
    .editor .writely-comment-yellow {
      background-color: #FF9;
      background-position: -240px 0;
    }
    .editor .writely-comment-yellow-hover {
      background-color: #FF0;
      background-position: -224px 0;
    }
    .editor .writely-comment-blue {
      background-color: #C0D3FF;
      background-position: -16px 0;
    }
    .editor .writely-comment-blue-hover {
      background-color: #6292FE;
      background-position: 0 0;
    }
    .editor .writely-comment-orange {
      background-color: #FFDEAD;
      background-position: -80px 0;
    }
    .editor .writely-comment-orange-hover {
      background-color: #F90;
      background-position: -64px 0;
    }
    .editor .writely-comment-green {
      background-color: #99FBB3;
      background-position: -48px 0;
    }
    .editor .writely-comment-green-hover {
      background-color: #00F442;
      background-position: -32px 0;
    }
    .editor .writely-comment-cyan {
      background-color: #CFF;
      background-position: -208px 0;
    }
    .editor .writely-comment-cyan-hover {
      background-color: #0FF;
      background-position: -192px 0;
    }
    .editor .writely-comment-purple {
      background-color: #EBCCFF;
      background-position: -144px 0;
    }
    .editor .writely-comment-purple-hover {
      background-color: #90F;
      background-position: -128px 0;
    }
    .editor .writely-comment-magenta {
      background-color: #FCF;
      background-position: -112px 0;
    }
    .editor .writely-comment-magenta-hover {
      background-color: #F0F;
      background-position: -96px 0;
    }
    .editor .writely-comment-red {
      background-color: #FFCACA;
      background-position: -176px 0;
    }
    .editor .writely-comment-red-hover {
      background-color: #FF7A7A;
      background-position: -160px 0;
    }

    .editor .writely-comment-marker {
      background-image: url('MISSING');
      background-color: transparent;
      padding-right: 11px;
      background-repeat: no-repeat;
      width: 16px;
      height: 16px;
      -moz-user-select: none;
    }

    .editor .writely-comment-hidden {
      padding: 0;
      background: none;
    }
    .editor .writely-comment-marker-hidden {
      background: none;
      padding: 0;
      width: 0;
    }
    .editor .writely-comment-none {
      opacity: .2;
      filter:progid:DXImageTransform.Microsoft.Alpha(opacity=20);
      -moz-opacity: .2;
    }
    .editor .writely-comment-none-hover {
      opacity: .2;
      filter:progid:DXImageTransform.Microsoft.Alpha(opacity=20);
      -moz-opacity: .2;
    }
  


  
  .br_fix span+br:not(:-moz-last-node) {
    
    position:relative;
    
    left: -1ex
    
  }

  
  #cb-p-tgt {
    font-size: 8pt;
    padding: .4em;
    background-color: #ddd;
    color: #333;
  }
  #cb-p-tgt-can {
    text-decoration: underline;
    color: #36c;
    font-weight: bold;
    margin-left: 2em;
  }
  #cb-p-tgt .spin {
    width: 16px;
    height: 16px;
    background: url(//ssl.gstatic.com/docs/clipboard/spin_16o.gif) no-repeat;
  }
}

h6 { font-size: 8pt }
h5 { font-size: 8pt }
h4 { font-size: 10pt }
h3 { font-size: 12pt }
h2 { font-size: 14pt }
h1 { font-size: 18pt }

blockquote {padding: 10px; border: 1px #DDD dashed }

.webkit-indent-blockquote { border: none; }

a img {border: 0}

.pb {
  border-width: 0;
  page-break-after: always;
  /* We don't want this to be resizeable, so enforce a width and height
     using !important */
  height: 1px !important;
  width: 100% !important;
}

.editor .pb {
  border-top: 1px dashed #C0C0C0;
  border-bottom: 1px dashed #C0C0C0;
}

div.google_header, div.google_footer {
  position: relative;
  margin-top: 1em;
  margin-bottom: 1em;
}


/* Table of contents */
.editor div.writely-toc {
  background-color: #f3f3f3;
  border: 1px solid #ccc;
}
.writely-toc > ol {
  padding-left: 3em;
  font-weight: bold;
}
ol.writely-toc-subheading {
  padding-left: 1em;
  font-weight: normal;
}
/* IE6 only */
* html writely-toc ol {
  list-style-position: inside;
}
.writely-toc-none {
  list-style-type: none;
}
.writely-toc-decimal {
  list-style-type: decimal;
}
.writely-toc-upper-alpha {
  list-style-type: upper-alpha;
}
.writely-toc-lower-alpha {
  list-style-type: lower-alpha;
}
.writely-toc-upper-roman {
  list-style-type: upper-roman;
}
.writely-toc-lower-roman {
  list-style-type: lower-roman;
}
.writely-toc-disc {
  list-style-type: disc;
}

/* Ordered lists converted to numbered lists can preserve ordered types, and
   vice versa. This is confusing, so disallow it */
ul[type="i"], ul[type="I"], ul[type="1"], ul[type="a"], ul[type="A"] {
  list-style-type: disc;
}

ol[type="disc"], ol[type="circle"], ol[type="square"] {
  list-style-type: decimal;
}

/* end default css */


  /* default print css */
  
  @media print {
    body {
      padding: 0;
      margin: 0;
    }

    div.google_header, div.google_footer {
      display: block;
      min-height: 0;
      border: none;
    }

    div.google_header {
      flow: static(header);
    }

    /* used to insert page numbers */
    div.google_header::before, div.google_footer::before {
      position: absolute;
      top: 0;
    }

    div.google_footer {
      flow: static(footer);
    }

    /* always consider this element at the start of the doc */
    div#google_footer {
      flow: static(footer, start);
    }

    span.google_pagenumber {
      content: counter(page);
    }

    span.google_pagecount {
      content: counter(pages);
    }

    .endnotes {
      page: endnote;
    }

    /* MLA specifies that endnotes title should be 1" margin from the top of the page. */
    @page endnote {
      margin-top: 1in;
    }

    callout.google_footnote {
      
      display: prince-footnote;
      footnote-style-position: inside;
      /* These styles keep the footnote from taking on the style of the text
         surrounding the footnote marker. They can be overridden in the
         document CSS. */
      color: #000;
      font-family: Verdana;
      font-size: 10.0pt;
      font-weight: normal;
    }

    /* Table of contents */
    #WritelyTableOfContents a::after {
      content: leader('.') target-counter(attr(href), page);
    }

    #WritelyTableOfContents a {
      text-decoration: none;
      color: black;
    }
  }

  @page {
    @top {
      content: flow(header);
    }
    @bottom {
      content: flow(footer);
    }
    @footnotes {
      border-top: solid black thin;
      padding-top: 8pt;
    }
  }
  /* end default print css */


/* custom css */


/* end custom css */

/* ui edited css */

body {
  font-family: Verdana;
  
  font-size: 10.0pt;
  line-height: normal;
  background-color: #ffffff;
}
/* end ui edited css */


/* editor CSS */
.editor a:visited {color: #551A8B}
.editor table.zeroBorder {border: 1px dotted gray}
.editor table.zeroBorder td {border: 1px dotted gray}
.editor table.zeroBorder th {border: 1px dotted gray}


.editor div.google_header, .editor div.google_footer {
  border: 2px #DDDDDD dashed;
  position: static;
  width: 100%;
  min-height: 2em;
}

.editor .misspell {background-color: yellow}

.editor .writely-comment {
  font-size: 9pt;
  line-height: 1.4;
  padding: 1px;
  border: 1px dashed #C0C0C0
}


/* end editor CSS */

</style>

  
  <title>K25 Ανάπτυξη Λογισμικού - BF</title>

</head><body>
    
    
    
<div style="text-align: center;">
  <div style="text-align: center;">
    <h1>
      Πληροφορική &amp; Τηλεπικοινωνίες K25<br>
      Ανάπτυξη Λογισμικού<br>
      Χειμερινό Εξάμηνο 2009-10<br>
      Καθηγητής Γιάννης Ιωαννίδης
    </h1>
  </div>
  <p>
  </p>
  <hr> <center>
  <h1>
    Μέρος 1ο, 3/3: Επίπεδο διαχείρισης μπλοκ<br>
  </h1>
  <h3>
    (Ημερομηνία Παράδοσης: Τρίτη, 17/11/2009, 17:00)
  </h3>
  <br>
  </center> <img src="BF_files/drawing_snTqL4lRg5wNfLcR_A-TMdA_110.png"><br>
  <br>
  &nbsp;
  <h2 style="text-align: left;">
    Εισαγωγή
  </h2>
  <div style="text-align: left;">
Το επίπεδο Αρχείου Μπλοκ υλοποιεί μια Διεπαφή Προγραμματισμού Εφαρμογών
που επιτρέπει στα παραπάνω επίπεδα να επικοινωνήσουν με το δίσκο
έχοντας σαν μονάδα επικοινωνίας το μπλοκ (τη σελίδα). Η διεπαφή
περιέχει συναρτήσεις για τη δημιουργία, το άνοιγμα, και το κλείσιμο
αρχείων, για τη σάρωση ενός δεδομένου αρχείου, για το διάβασμα
συγκεκριμένου μπλοκ ενός δεδομένου αρχείου, και για την πρόσθεση και
αφαίρεση μπλοκ από ένα δεδομένο αρχείο. </div>
  <p style="text-align: left;">
    <br>
  </p>
  <p style="text-align: left;">
Οι ρουτίνες της συγκεκριμένης Διεπαφής περιγράφονται παρακάτω. Τα
ονόματα όλων των ρουτινών αρχίζουν με το πρόθεμα BF, ώστε να
υποδεικνύουν το γεγονός ότι πρόκειται για υλοποίηση αρχείου σε επίπεδο
μπλοκ (BF=Block File). H γλώσσα υλοποίησης είναι η C. </p>
  <p style="text-align: left;"> Οι περισσότερες ρουτίνες
επιστρέφουν έναν ακέραιο αριθμό, όπου αρνητική τιμή σημαίνει ότι έχει
προκύψει κάποιο σφάλμα. Οι κωδικοί σφάλματος για όλα τα επιμέρους
τμήματα του BF είναι ίδιοι και έχουν οριστεί στο FMM. </p>
  <p style="text-align: left;">
    <br>
  </p>
  <p style="text-align: left;">
    Η εργασία αυτή είναι ατομική.
  </p>
  <hr style="margin-left: 0px; margin-right: auto;">
  <div>
  </div>
  <h2 style="text-align: left;">
    <img src="BF_files/MISSING.html">Ρουτίνες Υλοποίησης Επιπέδου Αρχείου Μπλοκ
  </h2>
  <div style="text-align: left;">
  </div>
  <h3 style="text-align: left;">
    BF_Init()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">void BF_Init( void )</font><br>
    Η ρουτίνα αυτή χρησιμοποιείται για να αρχικοποιήσετε τις επιμέρους μονάδες του επιπέδου αυτού.<br>
  </div>
  <h3 style="text-align: left;">
    BF_CreateFile()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_CreateFile(</font><br>
    <font face="Courier New"> char *fileName, /* όνομα αρχείου */</font><br>
    <font face="Courier New">)</font><br>
    <br>
    Η ρουτίνα αυτή δημιουργεί ένα αρχείο με όνομα <i>fileName</i>.
Το αρχείο δεν πρέπει να υπάρχει ήδη. Η ρουτίνα επιστρέφει BFE_OK εάν το
καινούργιο αρχείο δημιουργηθεί με επιτυχία, ειδ' αλλοιώς κάποιον κωδικό
σφάλματος. </div>
  <h3 style="text-align: left;">
    BF_DestroyFile()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_DestroyFile(</font><br>
    <font face="Courier New"> char *fileName /* όνομα αρχείου */</font><br>
    <font face="Courier New">)</font><br>
    <br>
    Η ρουτίνα αυτή καταστρέφει το αρχείο <i>fileName</i>,
σβήνοντας όλα τα δεδομένα του. Το αρχείο πρέπει να υπάρχει ήδη αλλά να
μην είναι ανοιχτό. Η ρουτίνα επιστρέφει BFE_OK εάν επιτύχει, ειδ'
αλλοιώς κάποιον κωδικό σφάλματος. </div>
  <h3 style="text-align: left;">
    BF_OpenFile()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_OpenFile (</font><br>
    <font face="Courier New"> char *fileName /* όνομα αρχείου */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα αυτή ανοίγει το αρχείο <i>fileName</i>.
Εάν το αρχείο ανοιχτεί κανονικά, η ρουτίνα επιστρέφει έναν μικρό μη
αρνητικό ακέραιο, ο οποίος χρησιμοποιείται για να αναγνωρίζεται το
αρχείο (όπως περιγράφουμε παρακάτω). Ειδ' αλλοιώς επιστρέφει κάποιον
κωδικό σφάλματος.<br>
  </div>
  <h3 style="text-align: left;">
    BF_CloseFile()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_CloseFile (</font><br>
    <font face="Courier New"> int fileDesc /* αριθμός που αντιστοιχεί σε ανοιχτό αρχείο */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα αυτή κλείνει το αρχείο με αναγνωριστικό αριθμό <i>fileDesc</i>.
Επίσης σβύνει την όλη καταχώρηση που αντιστοιχεί στο αρχείο αυτό στον
πίνακα ανοιχτών αρχείων. Επιστρέφει BFE_OK εάν το αρχείο κλείσει
επιτυχώς, ειδ' αλλοιώς κάποιον κωδικό σφάλματος. Ένα από τα σφάλματα
αντιστοιχεί σε απόπειρα κλεισίματος αρχείου ενώ κάποιο μπλοκ του είναι
``καρφωμένο'' στην ενδιάμεση μνήμη. </div>
  <h3 style="text-align: left;">
    BF_GetFirstBlock()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_GetFirstBlock(</font><br>
    <font face="Courier New"> int fileDesc /* αριθμός που αντιστοιχεί σε ανοιχτό αρχείο */</font><br>
    <font face="Courier New"> int *blockNum /* αριθμός του πρώτου μπλοκ του αρχείου */</font><br>
    <font face="Courier New"> char **blockBuf /* έμμεσος δείκτης προς την ενδιάμεση μνήμη */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα αυτή διαβάζει στην ενδιάμεση μνήμη το πρώτο έγγυρο μπλοκ του αρχείου με αναγνωριστικό αριθμό <i>fileDesc</i> και μετά βάζει τον δείκτη <i>*blockBuf</i> να δείχνει σ' αυτό. Επίσης αναθέτει στο <i>*blockNum</i>
τον αριθμό του μπλοκ που διαβάστηκε. Προσέξτε ότι αυτό δεν είναι
απαραίτητα το μπλοκ υπ' αριθμόν 1 (αν υποθέσουμε ότι η μέτρηση των
μπλοκ ξεκινά από εκεί), καθότι το τελευταίο (και ίσως και άλλα) μπορεί
να έχει επιστραφεί από το αρχείο στο σύστημα για ανακύκλωση. Το μπλοκ
που διαβάστηκε πρέπει να ``καρφωθεί'' στη μνήμη και να παραμείνει σ'
αυτήν την κατάσταση μέχρι να ``ξεκαρφωθεί'' μέσω της ρουτίνας <i>BF_UnpinBlock()</i>,
η οποία περιγράφεται παρακάτω. Η ρουτίνα επιστρέφει BFE_OK εάν
επιτύχει, BFE_EOF εάν έχουμε φτάσει στο τέλος του αρχείου (δηλαδή, εάν
το αρχείο δεν έχει κανένα μπλοκ), ή κάποιον κωδικό σφάλματος εάν κάτι
δεν λειτουργήσει όπως πρέπει. </div>
  <h3 style="text-align: left;">
    BF_GetNextBlock()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_GetNextBlock(</font><br>
    <font face="Courier New"> int fileDesc /* αριθμός που αντιστοιχεί σε ανοιχτό αρχείο */</font><br>
    <font face="Courier New"> int *blockNum /* αριθμός του μπλοκ του αρχείου το επόμενο του οποίου αναζητείται */</font><br>
    <font face="Courier New"> char **blockBuf /* έμμεσος δείκτης προς την ενδιάμεση μνήμη */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα αυτή διαβάζει στην ενδιάμεση μνήμη το πρώτο έγγυρο μπλοκ του αρχείου με αναγνωριστικό αριθμό <i>fileDesc</i> μετά από το μπλοκ με αριθμό <i>*blockNum</i> και μετά βάζει τον δείκτη <i>*blockBuf</i> να δείχνει σ' αυτό. Επίσης, στο τέλος της διαδικασίας, ενημερώνει το <i>*blockNum</i>
ώστε να περιέχει τον αριθμό του νέου μπλοκ που διαβάστηκε. Προσέξτε και
πάλι ότι αυτό δεν είναι απαραίτητα το αριθμητικά αμέσως επόμενο του <i>*blockNum</i>,
καθότι το τελευταίο (και ίσως και άλλα) μπορεί να έχει επιστραφεί από
το αρχείο στο σύστημα για ανακύκλωση. Το μπλοκ που διαβάστηκε πρέπει να
``καρφωθεί'' στη μνήμη και να παραμείνει σ' αυτήν την κατάσταση μέχρι
να ``ξεκαρφωθεί'' μέσω της ρουτίνας <i>BF_UnpinBlock()</i>, η οποία
περιγράφεται παρακάτω. Η ρουτίνα επιστρέφει BFE_OK εάν επιτύχει,
BFE_EOF εάν έχουμε φτάσει στο τέλος του αρχείου (δηλαδή δεν υπάρχει
επόμενο μπλοκ), BFE_INVALIDBLOCK εάν ο αρχικά δοσμένος αριθμός μπλοκ (<i>*blockNum</i>) δεν αναφέρεται σε έγγυρο μπλοκ, ή κάποιον άλλον κωδικό σφάλματος εάν κάτι άλλο δεν λειτουργήσει όπως πρέπει.
  </div>
  <h3 style="text-align: left;">
    BF_GetThisBlock()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_GetThisBlock(</font><br>
    <font face="Courier New"> int fileDesc /* αριθμός που αντιστοιχεί σε ανοιχτό αρχείο */</font><br>
    <font face="Courier New"> int blockNum /* αριθμός του αναζητούμενου μπλοκ του αρχείου */</font><br>
    <font face="Courier New"> char **blockBuf /* έμμεσος δείκτης προς την ενδιάμεση μνήμη */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα αυτή διαβάζει στην ενδιάμεση μνήμη το μπλοκ με αριθμό <i>blockNum</i> του αρχείου με αναγνωριστικό αριθμό <i>fileDesc</i> και μετά βάζει τον δείκτη <i>*blockBuf</i> να δείχνει σ' αυτό. Ο αριθμός <i>blockNum</i>
πρέπει να αναφέρεται σε έγγυρο μπλοκ. Το μπλοκ που διαβάστηκε πρέπει να
``καρφωθεί'' στη μνήμη και να παραμείνει σ' αυτήν την κατάσταση μέχρι
να ``ξεκαρφωθεί'' μέσω της ρουτίνας <i>BF_UnpinBlock()</i>, η οποία
περιγράφεται παρακάτω. Η ρουτίνα επιστρέφει BFE_OK εάν επιτύχει,
BFE_INVALIDBLOCK εάν ο αρχικά δοσμένος αριθμός μπλοκ (<i>blockNum</i>) δεν αναφέρεται σε έγγυρο μπλοκ, ή κάποιον άλλον κωδικό σφάλματος εάν κάτι άλλο δεν λειτουργήσει όπως πρέπει.
  </div>
  <h3 style="text-align: left;">
    BF_AllocBlock()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_AllocBlock(</font><br>
    <font face="Courier New"> int fileDesc /* αριθμός που αντιστοιχεί σε ανοιχτό αρχείο */</font><br>
    <font face="Courier New"> int *blockNum /* αριθμός του νέου μπλοκ του αρχείου */</font><br>
    <font face="Courier New"> char **blockBuf /* έμμεσος δείκτης προς την ενδιάμεση μνήμη */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα αυτή προσθέτει ένα νέο άδειο μπλοκ στο αρχείο με αναγνωριστικό αριθμό <i>fileDesc</i>. Αναθέτει τον αριθμό του νέου μπλοκ στο <i>*blockNum</i> και βάζει τον δείκτη <i>*blockBuf</i>
να δείχνει σε αντίστοιχο χώρο στην ενδιάμεση μνήμη. Το νέο μπλοκ μπορεί
να είναι πρωτοεμφανιζόμενο ή να προέρχεται από ανακύκλωση. Επίσης το
νέο μπλοκ πρέπει να ``καρφωθεί'' στη μνήμη και να παραμείνει σ' αυτήν
την κατάσταση μέχρι να ``ξεκαρφωθεί'' μέσω της ρουτίνας <i>BF_UnpinBlock()</i>,
η οποία περιγράφεται παρακάτω. Η ρουτίνα επιστρέφει BFE_OK εάν επιτύχει
ή κάποιον κωδικό σφάλματος εάν κάτι δεν λειτουργήσει όπως πρέπει. </div>
  <h3 style="text-align: left;">
    BF_DisposeBlock()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_DisposeBlock(</font><br>
    <font face="Courier New"> int fileDesc /* αριθμός που αντιστοιχεί σε ανοιχτό αρχείο */</font><br>
    <font face="Courier New"> int blockNum /* αριθμός του ανακυκλούμενου μπλοκ του αρχείου */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα αυτή επιστρέφει προς ανακύκλωση το μπλοκ με αριθμό <i>blockNum</i> του αρχείου με αναγνωριστικό αριθμό <i>fileDesc</i>.
To μπλοκ δεν μπορεί να είναι ``καρφωμένο'' στην ενδιάμεση μνήμη. Η
ρουτίνα επιστρέφει BFE_OK εάν επιτύχει ή κάποιον κωδικό σφάλματος εάν
κάτι δεν λειτουργήσει όπως πρέπει. </div>
  <h3 style="text-align: left;">
    BF_UnpinBlock()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">int BF_UnpinBlock(</font><br>
    <font face="Courier New"> int fileDesc /* αριθμός που αντιστοιχεί σε ανοιχτό αρχείο */</font><br>
    <font face="Courier New"> int blockNum /* αριθμός του μπλοκ του αρχείου που ``ξεκαρφώνεται'' */</font><br>
    <font face="Courier New"> int dirty /* ένδειξη αλλαγής του μπλοκ στην ενδιάμεση μνήμη */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα αυτή ειδοποιεί ότι το μπλοκ με αριθμό <i>blockNum</i> του αρχείου με αναγνωριστικό αριθμό <i>fileDesc</i> δεν χρειάζεται πια στην ενδιάμεση μνήμη και μπορεί να ``ξεκαρφωθεί''. Η παράμετρος dirty είναι ίση με <i>TRUE</i>=1
εάν το μπλοκ έχει αλλάξει στην ενδιάμεση μνήμη από τη στιγμή που
``καρφώθηκε'' εκεί (οπότε σε περίπτωση αντικατάστασής του πρέπει πρώτα
να γραφτεί στη θέση του στο δίσκο), ειδ' αλλοιώς είναι ίση με <i>FALSE</i>=0. Η ρουτίνα επιστρέφει BFE_OK εάν επιτύχει ή κάποιον κωδικό σφάλματος εάν κάτι δεν λειτουργήσει όπως πρέπει.
  </div>
  <h3 style="text-align: left;">
    BF_PrintError()
  </h3>
  <div style="text-align: left;">
    <font face="Courier New">void BF_PrintError(</font><br>
    <font face="Courier New"> char *errString /* κείμενο για εκτύπωση */</font><br>
    <font face="Courier New">)</font><br>
    Η ρουτίνα τυπώνει το κείμενο που δείχνει η παράμετρος <i>errString</i>,
και μετά τυπώνει το μήνυμα που αντιστοιχεί στο τελευταίο σφάλμα που
προέκυψε από οποιαδήποτε από τις ρουτίνες. Για τον σκοπό αυτό, η
ρουτίνα αυτή χρησιμοποιεί μία καθολική (global) μεταβλητή <i>BF_errno</i>
η οποία αποθηκεύει πάντα τον κωδικό του πλέον πρόσφατου σφάλματος. Ο
κωδικός αυτός σφάλματος πρέπει πάντα να ενημερώνεται σωστά σε όλες τις
άλλες ρουτίνες. Η ρουτίνα αυτή δεν έχει δική της τιμή επιστροφής. </div>
  <hr style="margin-left: 0px; margin-right: auto;">
  <div style="text-align: left;">
  </div>
  <img src="BF_files/MISSING.html"><img src="BF_files/MISSING.html"><br>
  <br>
  <div style="text-align: left;">
    <b><font size="4">Κωδικοί λαθών</font></b><br>
    <br>
#define BFE_OK&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;/* OK */<br>
#define BFE_NOMEM&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Δεν υπάρχει διαθέσιμη
μνήμη */<br>
#define BFE_CANNOTOPENFILE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Αδύνατο το
άνοιγμα του αρχείου */<br>
#define
BFE_CANNOTCLOSEFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Αδύνατο το κλείσιμο του αρχείου */<br>
#define BFE_CANNOTCREATEFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Αδύνατη η δημιουργία του αρχείου */<br>
#define
BFE_INCOMPLETEREAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Ημιτελές διάβασμα */<br>
#define
BFE_INCOMPLETEWRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Ημιτελές γράψιμο */<br>
#define
BFE_FILEEXISTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Το αρχείο υπάρχει ήδη */<br>
#define
BFE_NOBUF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Έλλειψη χώρου στην ενδιάμεση
μνήμη */<br>
#define
BFE_FILEOPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-10&nbsp;&nbsp;&nbsp;&nbsp; /* Το αρχείο είναι ήδη ανοιχτό */<br>
#define
BFE_FD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-11&nbsp;&nbsp;&nbsp;&nbsp; /* Λανθασμένο αναγνωριστικό αρχείου */<br>
#define
BFE_FILENOTEXISTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-12&nbsp;&nbsp;&nbsp; /* Το αρχείο δεν υπάρχει */<br>
#define
BFE_FTABFULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-13&nbsp;&nbsp;&nbsp; /* Λίστα ανοιχτών αρχείων πλήρης */<br>
#define
BFE_HEADOVERFLOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-14&nbsp;&nbsp;&nbsp; /* Λανθασμένος αριθμός&nbsp; */<br>
#define
BFE_BLOCKFIXED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-15&nbsp;&nbsp;&nbsp; /* Μπλοκ ήδη "καρφωμένο" στη μνήμη */<br>
#define
BFE_BLOCKUNFIXED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-16&nbsp;&nbsp;&nbsp; /* Μπλοκ ήδη ξεκαρφωμένο */<br>
#define
BFE_EOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-17&nbsp;&nbsp;&nbsp; /* Τέλος αρχείου */<br>
    #define BFE_FILEHASFIXEDBLOCKS&nbsp;&nbsp;&nbsp; -18&nbsp;&nbsp;&nbsp; /* Το αρχείο έχει καρφωμένα block */<br>
#define
BFE_BLOCKFREE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-19&nbsp;&nbsp; /* Μπλοκ ήδη διαθέσιμο προς ανακύκλωση */<br>
#define
BFE_BLOCKINBUF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-20&nbsp;&nbsp; /* Μπλοκ ήδη στη μνήμη */<br>
#define
BFE_BLOCKNOTINBUF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-21&nbsp;&nbsp; /* Μπλοκ όχι στη μνήμη */<br>
#define
BFE_INVALIDBLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-22&nbsp;&nbsp; /* Λανθασμένος κωδικός block */<br>
    #define BFE_CANNOTDESTROYFILE&nbsp;&nbsp; &nbsp; -23&nbsp;&nbsp; /* Αδύνατη η καταστροφή του αρχείου */<br>
    <br>
#define
BF_BUFFER_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Μέγεθος της ενδιάμεσης μνήμης
σε block */<br>
#define
MAXOPENFILES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Μέγιστο πλήθος ανοιχτών
αρχείων */<br>
#define
BF_BLOCK_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1024&nbsp;&nbsp;&nbsp; /* Μέγεθος ενός block σε bytes */<br>
#define
MAX_BLOCKS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
8192&nbsp;&nbsp;&nbsp;&nbsp; /* Μέγιστο πλήθος από διαθέσιμα block ανά
αρχείο */<br>
#define
MAX_FILE_NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
256&nbsp;&nbsp;&nbsp;&nbsp; /* Μέγιστο μέγεθος για όνομα ενός αρχείου */<br>
  </div>
  <br>
  <br>
  <h2 style="text-align: left;">
    Σχόλια για την Υλοποίηση
  </h2>
  <div style="text-align: left;">
Η υλοποίηση όλων των συναρτήσεων θα πρέπει να χρησιμοποιούν τις
εσωτερικές μονάδες που έχετε (θα έχετε) υλοποιήσει στα δύο πρώτα
κομμάτια της εργασίας. </div>
  <hr style="margin-left: 0px; margin-right: auto;">
  <div style="text-align: left;">
  </div>
  <h2 style="text-align: left;">
    <img src="BF_files/MISSING.html"> Σχολιασμός, Έλεγχος Σφαλμάτων, και Γενική Μορφοποίηση
  </h2>
  <div style="text-align: left;">
Όπως πάντοτε, αναμένεται καλός σχολιασμός του προγράμματος, και
εσωτερικός (ανάμεσα στις γραμμές κώδικα) και εξωτερικός (στην αρχή κάθε
ρουτίνας). Ένας γενικός κανόνας είναι να σχολιάζετε τα προγράμματά σας
σαν να πρόκειται να τα δώσετε σε κάποιον άλλον ο οποίος θα τα
επεκτείνει και ο οποίος δεν έχει ιδέα για το τι κάνατε όταν τα γράφατε
(και δεν μπορεί ούτε να σας βρει να σας ρωτήσει). </div>
  <p style="text-align: left;"> Επίσης, θα πρέπει να
ελέγχετε για διάφορα σφάλματα που μπορούν να προκύψουν και να
βεβαιωθειτε ότι ο κώδικάς σας τερματίζει ομαλά, με μηνύματα που έχουν
νόημα, σε όλες τις εισόδους που ικανοποιούν την παραπάνω περιγραφή. </p>
  <hr style="margin-left: 0px; margin-right: auto;">
  <div style="text-align: left;">
  </div>
  <h2 style="text-align: left;">
    <img src="BF_files/MISSING.html">Διαδικαστικές Λεπτομέρειες
  </h2>
  <div style="text-align: left;">
Το τί ακριβώς θα παραδώσετε, πού θα βρείτε τα αρχεία με τα οποία θα
ελέγξετε τελικά το πρόγραμμά σας, κτλ., θα ανακοινωθεί σύντομα. </div>
  <p style="text-align: left;"> Τα προγράμματά σας θα πρέπει
να δουλεύουν στα μηχανήματα του τμήματος (είτε στα sun (Linux) είτε στα
pc (Windows)) ώστε να μπορούν να ελεγχθούν. Ακόμη και αν δουλέψετε σε
δικούς σας υπολογιστές θα πρέπει να βεβαιωθείτε ότι το τελικό
αποτέλεσμα δουλεύει και εδώ τοπικά. Η έκδοση της C που θα
χρησιμοποιήσετε πρέπει να έχει ακέραιους των 4 bytes και να επιτρέπει
αλλαγή ερμηνείας τύπου δεδομένων (type casting). </p>
</div>
<hr size="2"><br></body></html>