<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html class="pageview"><head>







<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- base -->
<style type="text/css">
  

/* default css */

table {
  font-size: 1em;
  line-height: inherit;
  border-collapse: collapse;
}


tr {
  
  text-align: left;
  
}


div, address, ol, ul, li, option, select {
  margin-top: 0px;
  margin-bottom: 0px;
}

p {
  margin: 0px;
}


pre {
  font-family: Courier New;
  white-space: pre-wrap;
  margin:0;
}

body {
  margin: 6px;
  padding: 0px;
  font-family: Verdana, sans-serif;
  font-size: 10pt;
  background-color: #ffffff;
}


img {
  -moz-force-broken-image-icon: 1;
}

@media screen {
  html.pageview {
    background-color: #f3f3f3 !important;
    overflow-x: hidden;
    overflow-y: scroll;
  }

  

  body {
    min-height: 1100px;
    
    counter-reset: __goog_page__;
  }
  * html body {
    height: 1100px;
  }
  .pageview body {
    border-top: 1px solid #ccc;
    border-left: 1px solid #ccc;
    border-right: 2px solid #bbb;
    border-bottom: 2px solid #bbb;
    width: 648px !important;
    margin: 15px auto 25px;
    padding: 40px 50px;
  }
  /* IE6 */
  * html {
    overflow-y: scroll;
  }
  * html.pageview body {
    overflow-x: auto;
  }
  /* Prevent repaint errors when scrolling in Safari. This "Star-7" css hack
     targets Safari 3.1, but not WebKit nightlies and presumably Safari 4.
     That's OK because this bug is fixed in WebKit nightlies/Safari 4 :-). */
  html*#wys_frame::before {
    content: '\A0';
    position: fixed;
    overflow: hidden;
    width: 0;
    height: 0;
    top: 0;
    left: 0;
  }
  
  

  
    .writely-callout-data {
      display: none;
      *display: inline-block;
      *width: 0;
      *height: 0;
      *overflow: hidden;
    }
    .writely-footnote-marker {
      background-image: url('MISSING');
      background-color: transparent;
      background-repeat: no-repeat;
      width: 7px;
      overflow: hidden;
      height: 16px;
      vertical-align: top;

      
      -moz-user-select: none;
    }
    .editor .writely-footnote-marker {
      cursor: move;
    }
    .writely-footnote-marker-highlight {
      background-position: -15px 0;
      -moz-user-select: text;
    }
    .writely-footnote-hide-selection ::-moz-selection, .writely-footnote-hide-selection::-moz-selection {
      background: transparent;
    }
    .writely-footnote-hide-selection ::selection, .writely-footnote-hide-selection::selection {
      background: transparent;
    }
    .writely-footnote-hide-selection {
      cursor: move;
    }

    
    .editor .writely-comment-yellow {
      background-color: #FF9;
      background-position: -240px 0;
    }
    .editor .writely-comment-yellow-hover {
      background-color: #FF0;
      background-position: -224px 0;
    }
    .editor .writely-comment-blue {
      background-color: #C0D3FF;
      background-position: -16px 0;
    }
    .editor .writely-comment-blue-hover {
      background-color: #6292FE;
      background-position: 0 0;
    }
    .editor .writely-comment-orange {
      background-color: #FFDEAD;
      background-position: -80px 0;
    }
    .editor .writely-comment-orange-hover {
      background-color: #F90;
      background-position: -64px 0;
    }
    .editor .writely-comment-green {
      background-color: #99FBB3;
      background-position: -48px 0;
    }
    .editor .writely-comment-green-hover {
      background-color: #00F442;
      background-position: -32px 0;
    }
    .editor .writely-comment-cyan {
      background-color: #CFF;
      background-position: -208px 0;
    }
    .editor .writely-comment-cyan-hover {
      background-color: #0FF;
      background-position: -192px 0;
    }
    .editor .writely-comment-purple {
      background-color: #EBCCFF;
      background-position: -144px 0;
    }
    .editor .writely-comment-purple-hover {
      background-color: #90F;
      background-position: -128px 0;
    }
    .editor .writely-comment-magenta {
      background-color: #FCF;
      background-position: -112px 0;
    }
    .editor .writely-comment-magenta-hover {
      background-color: #F0F;
      background-position: -96px 0;
    }
    .editor .writely-comment-red {
      background-color: #FFCACA;
      background-position: -176px 0;
    }
    .editor .writely-comment-red-hover {
      background-color: #FF7A7A;
      background-position: -160px 0;
    }

    .editor .writely-comment-marker {
      background-image: url('MISSING');
      background-color: transparent;
      padding-right: 11px;
      background-repeat: no-repeat;
      width: 16px;
      height: 16px;
      -moz-user-select: none;
    }

    .editor .writely-comment-hidden {
      padding: 0;
      background: none;
    }
    .editor .writely-comment-marker-hidden {
      background: none;
      padding: 0;
      width: 0;
    }
    .editor .writely-comment-none {
      opacity: .2;
      filter:progid:DXImageTransform.Microsoft.Alpha(opacity=20);
      -moz-opacity: .2;
    }
    .editor .writely-comment-none-hover {
      opacity: .2;
      filter:progid:DXImageTransform.Microsoft.Alpha(opacity=20);
      -moz-opacity: .2;
    }
  


  
  .br_fix span+br:not(:-moz-last-node) {
    
    position:relative;
    
    left: -1ex
    
  }

  
  #cb-p-tgt {
    font-size: 8pt;
    padding: .4em;
    background-color: #ddd;
    color: #333;
  }
  #cb-p-tgt-can {
    text-decoration: underline;
    color: #36c;
    font-weight: bold;
    margin-left: 2em;
  }
  #cb-p-tgt .spin {
    width: 16px;
    height: 16px;
    background: url(//ssl.gstatic.com/docs/clipboard/spin_16o.gif) no-repeat;
  }
}

h6 { font-size: 8pt }
h5 { font-size: 8pt }
h4 { font-size: 10pt }
h3 { font-size: 12pt }
h2 { font-size: 14pt }
h1 { font-size: 18pt }

blockquote {padding: 10px; border: 1px #DDD dashed }

.webkit-indent-blockquote { border: none; }

a img {border: 0}

.pb {
  border-width: 0;
  page-break-after: always;
  /* We don't want this to be resizeable, so enforce a width and height
     using !important */
  height: 1px !important;
  width: 100% !important;
}

.editor .pb {
  border-top: 1px dashed #C0C0C0;
  border-bottom: 1px dashed #C0C0C0;
}

div.google_header, div.google_footer {
  position: relative;
  margin-top: 1em;
  margin-bottom: 1em;
}


/* Table of contents */
.editor div.writely-toc {
  background-color: #f3f3f3;
  border: 1px solid #ccc;
}
.writely-toc > ol {
  padding-left: 3em;
  font-weight: bold;
}
ol.writely-toc-subheading {
  padding-left: 1em;
  font-weight: normal;
}
/* IE6 only */
* html writely-toc ol {
  list-style-position: inside;
}
.writely-toc-none {
  list-style-type: none;
}
.writely-toc-decimal {
  list-style-type: decimal;
}
.writely-toc-upper-alpha {
  list-style-type: upper-alpha;
}
.writely-toc-lower-alpha {
  list-style-type: lower-alpha;
}
.writely-toc-upper-roman {
  list-style-type: upper-roman;
}
.writely-toc-lower-roman {
  list-style-type: lower-roman;
}
.writely-toc-disc {
  list-style-type: disc;
}

/* Ordered lists converted to numbered lists can preserve ordered types, and
   vice versa. This is confusing, so disallow it */
ul[type="i"], ul[type="I"], ul[type="1"], ul[type="a"], ul[type="A"] {
  list-style-type: disc;
}

ol[type="disc"], ol[type="circle"], ol[type="square"] {
  list-style-type: decimal;
}

/* end default css */


  /* default print css */
  
  @media print {
    body {
      padding: 0;
      margin: 0;
    }

    div.google_header, div.google_footer {
      display: block;
      min-height: 0;
      border: none;
    }

    div.google_header {
      flow: static(header);
    }

    /* used to insert page numbers */
    div.google_header::before, div.google_footer::before {
      position: absolute;
      top: 0;
    }

    div.google_footer {
      flow: static(footer);
    }

    /* always consider this element at the start of the doc */
    div#google_footer {
      flow: static(footer, start);
    }

    span.google_pagenumber {
      content: counter(page);
    }

    span.google_pagecount {
      content: counter(pages);
    }

    .endnotes {
      page: endnote;
    }

    /* MLA specifies that endnotes title should be 1" margin from the top of the page. */
    @page endnote {
      margin-top: 1in;
    }

    callout.google_footnote {
      
      display: prince-footnote;
      footnote-style-position: inside;
      /* These styles keep the footnote from taking on the style of the text
         surrounding the footnote marker. They can be overridden in the
         document CSS. */
      color: #000;
      font-family: Verdana;
      font-size: 10.0pt;
      font-weight: normal;
    }

    /* Table of contents */
    #WritelyTableOfContents a::after {
      content: leader('.') target-counter(attr(href), page);
    }

    #WritelyTableOfContents a {
      text-decoration: none;
      color: black;
    }
  }

  @page {
    @top {
      content: flow(header);
    }
    @bottom {
      content: flow(footer);
    }
    @footnotes {
      border-top: solid black thin;
      padding-top: 8pt;
    }
  }
  /* end default print css */


/* custom css */


/* end custom css */

/* ui edited css */

body {
  font-family: Verdana;
  
  font-size: 10.0pt;
  line-height: normal;
  background-color: #ffffff;
}
/* end ui edited css */


/* editor CSS */
.editor a:visited {color: #551A8B}
.editor table.zeroBorder {border: 1px dotted gray}
.editor table.zeroBorder td {border: 1px dotted gray}
.editor table.zeroBorder th {border: 1px dotted gray}


.editor div.google_header, .editor div.google_footer {
  border: 2px #DDDDDD dashed;
  position: static;
  width: 100%;
  min-height: 2em;
}

.editor .misspell {background-color: yellow}

.editor .writely-comment {
  font-size: 9pt;
  line-height: 1.4;
  padding: 1px;
  border: 1px dashed #C0C0C0
}


/* end editor CSS */

</style>

  
  <title>UT-DM - Utilities</title>

</head><body>
    
    
    
<div style="font-family: Verdana;">
  <div style="text-align: center;">
    <h1>
      Πληροφορική &amp; Τηλεπικοινωνίες K25<br>
      Ανάπτυξη Λογισμικού<br>
      Χειμερινό Εξάμηνο 2009-10<br>
      Καθηγητής Γιάννης Ιωαννίδης
    </h1>
  </div>
  <p>
  </p>
  <hr>
  <h1 style="text-align: center;">
    Μέρος 3ο, 1/2: Βοηθητικές συναρτήσεις
  </h1>
  <div>
  </div>
  <h3 style="text-align: center;">
    (Ημερομηνία Παράδοσης: Τρίτη, 22/12/2010, 17:00)
  </h3>
  <br>
  <br>
  <div style="text-align: center;">
    <img src="UT_files/drawing_sq5SI6h_D9MxTY68XYuUcaw_9.png">
    <div style="text-align: left;">
      <br>
    </div>
  </div>
  <br>
  <div style="text-align: justify;">
    Για την ολοκλήρωση της όλης εργασίας απαιτείται η κατασκευή των παρακάτω δύο προγραμμάτων:
  </div>
  <ol>
    <li>
      dbcreate
    </li>
    <li>
      dbdestroy
    </li>
  </ol>
  <br>
  <h3>
    1 - dbcreate
  </h3>
  <p>
    Το πρόγραμμα <i>dbcreate</i> είναι ένα (μικρό) βοήθημα που χρησιμοποιείται για την δημιουργία νέων βάσεων δεδομένων.
  </p>
  <p>
    <br>
  </p>
  <p style="text-align: justify;">
    <b>Σύνταξη:</b> Η λειτουργία του προγράμματος είναι εξαιρετικά απλή. Αρκεί στην γραμμή εντολών ο χρήστης να πληκτρολογήσει <i>dbcreate dbName</i> και το πρόγραμμα δημιουργεί μία νέα βάση δεδομένων με όνομα <i>dbName</i>. Η βάση αυτή μπορεί στην συνέχεια να χρησιμοποιηθεί από το πρόγραμμα <i>aminirel</i> ή μπορεί να διαγραφεί με την βοήθεια του <i>dbdestroy</i>.
  </p>
  <div>
  </div>
  <p style="text-align: justify;">
    <br>
  </p>
  <p style="text-align: justify;">
    <b>Πληροφορίες υλοποίησης:</b>
Κάθε βάση αποτελείται από ένα σύνολο από σχέσεις και ευρετήρια. Τα
αρχεία αυτά τοποθετούνται μέσα σε ένα φάκελο που έχει το ίδιο όνομα με
την βάση. Επομένως, η δημιουργία μία νέας βάσης με όνομα <i>dbName</i>, ισοδυναμεί με την δημιουργία ενός νέου φακέλου με όνομα <i>dbName</i> και την κατασκευή (μέσα σε αυτόν) των πινάκων που αφορούν τα μεταδεδομένα (σχέσεις <i>relCat</i>, <i>attrCat</i> κλπ.) της βάσης.
  </p>
  <div style="text-align: justify;">
  </div>
  <p style="text-align: justify;">
Οι σχέσεις θα δημιουργηθούν χρησιμοποιώντας κατάλληλα τις συναρτήσεις
του επιπέδου HF. Φυσικά, αν το επιθυμείτε, μπορείτε να δημιουργήσετε
και ευρετήρια με σκοπό την επιτάχυνση της χρήσης των σχέσεων αυτών. </p>
  <div style="text-align: justify;">
  </div>
  <p style="text-align: justify;">
Για τη δημιουργία φακέλων, δεν έχει γίνει καμία πρόβλεψη από το πρότυπο
της C. Για αυτό τον λόγο θα πρέπει να χρησιμοποιήσετε την <i>mkdir</i> του κελύφους. Για παράδειγμα, για να φτιάξετε τον φάκελο <i>foo</i>, θα πρέπει να χρησιμοποιήσετε την εντολή <i>system("mkdir foo")</i>.
  </p>
  <div style="text-align: justify;">
  </div>
  <p style="text-align: justify;">
    Σε γενικές γραμμές, η συνάρτηση <i>main()</i> του <i>dbcreate</i> θα έχει την ακόλουθη μορφή:
  </p>
  <font face="Courier New"><br>
  int main(int argc, char* argv[]){<br>
  &nbsp;&nbsp; &nbsp;char command[80];<br>
  &nbsp;&nbsp; &nbsp;char* dbname;<br>
  <br>
  &nbsp;&nbsp; &nbsp;if(argc!=2){<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf("Χρήση: %s dbname \n",argv[0]);<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return(1);<br>
  &nbsp;&nbsp; &nbsp;}<br>
  </font> <font face="Courier New"> &nbsp;&nbsp;&nbsp;<br>
  &nbsp;&nbsp; &nbsp;dbname=argv[1];<br>
  &nbsp;&nbsp; &nbsp;sprintf(command,"mkdir %s",dbname);<br>
  &nbsp;&nbsp; &nbsp;system(command);<br>
  &nbsp;&nbsp;&nbsp;<br>
  &nbsp;&nbsp; &nbsp;if(chdir(dbname)){<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf("Δεν είναι δυνατή η δημιουργία της βάσης");<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return(2);<br>
  &nbsp;&nbsp; &nbsp;}<br>
  <br>
  &nbsp;&nbsp; &nbsp;/* Δημιουργία των πινάκων relCat και attrCat με χρήση των<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;συναρτήσεων ΗF_CreateFile */<br>
  &nbsp;&nbsp; &nbsp;.<br>
  &nbsp;&nbsp; &nbsp;.<br>
  &nbsp;&nbsp; &nbsp;.<br>
  <br>
  &nbsp;&nbsp; &nbsp;return 0;<br>
  }<br>
  <br>
  </font>
  <h3>
    2 - dbdestroy
  </h3>
  <div style="text-align: justify;">
    Το πρόγραμμα <i>dbdestroy</i> είναι ένα (μικρό) βοήθημα που χρησιμοποιείται για την διαγραφή βάσεων δεδομένων.
  </div>
  <p style="text-align: justify;">
    <br>
  </p>
  <p style="text-align: justify;">
    <b>Σύνταξη:</b> Η λειτουργία του προγράμματος είναι εξαιρετικά απλή. Αρκεί στη γραμμή εντολών ο χρήστης να πληκτρολογήσει <i>dbdestroy dbName</i> και το πρόγραμμα διαγράφει τη βάση δεδομένων με όνομα <i>dbName</i>.
  </p>
  <div>
  </div>
  <p style="text-align: justify;">
    <br>
  </p>
  <p style="text-align: justify;">
    <b>Πληροφορίες υλοποίησης:</b>
Κάθε βάση αποτελείται από ένα σύνολο από σχέσεις και ευρετήρια. Τα
αρχεία αυτά τοποθετούνται μέσα σε ένα φάκελο που έχει το ίδιο όνομα με
την βάση. Επομένως, η διαγραφή μιας βάσης με όνομα <i>dbName</i>, ισοδυναμεί με την διαγραφή του φακέλου αυτού.
  </p>
  <div style="text-align: justify;">
  </div>
  <p style="text-align: justify;">
Για την διαγραφή φακέλων, δεν έχει γίνει καμία πρόβλεψη από το πρότυπο
της C. Για αυτό τον λόγο θα πρέπει να χρησιμοποιήσετε την εντολή <i>rm</i> του κελύφους. Για παράδειγμα, για να διαγράψετε τον φάκελο <i>foo</i>, θα πρέπει να χρησιμοποιήσετε την εντολή <i>system("rm -r foo"). </i>Προσοχή: Αν προγραμματίζετε σε περιβάλλον Ms-Windows, θα πρέπει να χρησιμοποιήσετε τις αντίστοιχες εντολές <i>system("del</i> /<i>q foo") </i>και <i>system("rmdir foo").</i>
  </p>
  <div style="text-align: justify;">
  </div>
  <p style="text-align: justify;">
    Σε γενικές γραμμές, η συνάρτηση <i>main()</i> του <i>dbdestroy</i> θα έχει την ακόλουθη μορφή:
  </p>
  <font face="Courier New"><br>
  int main(int argc, char* argv[]){<br>
  &nbsp;&nbsp; &nbsp;char command[80];<br>
  &nbsp;&nbsp; &nbsp;char* dbname;<br>
  <br>
  &nbsp;&nbsp; &nbsp;if(argc!=2){<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf("Χρήση: %s dbdestroy \n",argv[0]);<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return(1);<br>
  &nbsp;&nbsp; &nbsp;}<br>
  </font> <font face="Courier New"> &nbsp;&nbsp; &nbsp;dbname=argv[1];<br>
  &nbsp;&nbsp; &nbsp;sprintf(command,"rm -r %s",dbname);<br>
  &nbsp;&nbsp; &nbsp;system(command);<br>
  <br>
  &nbsp;&nbsp; &nbsp;return 0;<br>
  }<br>
  </font><br>
  <br>
</div>
<div style="font-family: Verdana;">
  <div style="text-align: center;">
    <i><b><font size="5">CFM (Catalog Functionality Module)</font></b></i><br>
  </div>
  <br>
  <p style="text-align: justify;">
Ένα από τα ωραία πράγματα των σχεσιακών συστημάτων βάσεων δεδομένων
είναι ότι η εσωτερική πληροφορία που κρατούν για το σχήμα κάθε βάσης
(τους πίνακες, τα πεδία τους, τα ευρετήριά τους, κτλ.) διατηρείται και
αυτή σε πίνακες. Οι πίνακες αυτοί ανήκουν στο ίδιο το σύστημα και
λέγονται <i>κατάλογοι</i>.
  </p>
  <p style="text-align: justify;">
    Υπάρχουν πάντα δύο βασικοί κατάλογοι: <i>relCat</i> και <i>attrCat</i>. Και οι δύο αυτοί πίνακες δημιουργούνται όταν η εντολή <i>dbcreate dbname</i> εκτελείται. Μπαίνουν στο φάκελο <i>dbname</i> που δημιουργείται, καθότι κάθε βάση έχει το δικό της σχήμα. Πρέπει να χρησιμοποιήσετε την <i>HF_CreateFile</i>
για να δημιουργήσετε τους δύο πίνακες ώστε να μπορείτε μετά να τους
διαχειριστείτε με τις κανονικές ρουτίνες που έχετε φτιάξει για τους
υπόλοιπους πίνακες. Για παράδειγμα, μπορείτε αν θέλετε να ορίσετε και
ευρετήρια πάνω σε κάποια πεδία των καταλόγων ώστε οι πρόσβαση σ' αυτούς
να είναι γρήγορη. Αυτό σημαίνει ότι το πρόγραμμα C που θα φτιάξετε για
την <i>dbcreate</i> πρέπει να μεταφραστεί μαζί με τα επίπεδα HF και AM.
  </p>
  <p style="text-align: justify;">
    Ο πίνακας <i>relCat</i> θα χρησιμοποιηθεί για να κρατά στοιχεία για κάθε πίνακα μιας βάσης. Κάθε εγγραφή του πίνακα <i>relCat</i> θα πρέπει να έχει την εξής δομή (ή κάτι παρόμοιο) αν την εκφράζαμε σε μορφή C:
  </p>
  <font face="Courier New"><br>
  typedef struct {<br>
  &nbsp;&nbsp; &nbsp;char relname[MAXNAME]; /* όνομα πίνακα */<br>
  &nbsp;&nbsp; &nbsp;int relwidth; /* εύρος εγγραφής πίνακα σε bytes */<br>
  &nbsp;&nbsp; &nbsp; int attrcnt; /* αριθμός πεδίων εγγραφής */<br>
  &nbsp;&nbsp; &nbsp;int indexcnt; /* αριθμός ευρετηρίων πίνακα */<br>
  } relDesc;<br>
  <br>
  </font>
  <div style="text-align: justify;">
    Ο πίνακας <i>attrCat</i> θα χρησιμοποιηθεί για να κρατά στοιχεία για κάθε πεδίο κάθε πίνακα μιας βάσης. Κάθε εγγραφή του πίνακα <i>attrCat</i> θα πρέπει να έχει την εξής δομή (ή κάτι παρόμοιο) αν την εκφράζαμε σε μορφή C:<br>
  </div>
  <br>
  <font face="Courier New">typedef struct {<br>
  &nbsp;&nbsp; &nbsp;char relname[MAXNAME]; /* όνομα πίνακα */<br>
  &nbsp;&nbsp; &nbsp;char attrname[MAXNAME]; /* όνομα πεδίου του πίνακα */<br>
  &nbsp;&nbsp; &nbsp;int offset; /* απόσταση αρχής πεδίου από την αρχή της εγγραφής σε bytes */<br>
  &nbsp;&nbsp; &nbsp;int attrlength; /* μήκος πεδίου σε bytes */<br>
  &nbsp;&nbsp; &nbsp;char attrtype; /* τύπος πεδίου ('i', 'f', ή 'c' */<br>
  &nbsp;&nbsp; &nbsp;int indexed; /* TRUE αν το πεδίο έχει ευρετήριο */<br>
  &nbsp;&nbsp; &nbsp;int indexno; /* αύξον αριθμός του ευρετηρίου αν indexed=TRUE */<br>
  } attrDesc;</font><br>
  <br>
  <p style="text-align: justify;">
    Παρατηρείστε ότι οι πίνακες <i>relCat</i> και <i>attrCat</i> θα πρέπει να περιέχουν πληροφορία και για τον εαυτό τους. Δηλαδή στον πίνακα <i>relCat</i> θα πρέπει να υπάρχει μια εγγραφή για τον εαυτό του και και μια για τον <i>attrCat</i> και αντίστοιχα στον πίνακα <i>attrCat</i> θα πρέπει να υπάρχουν τέσσερις εγγραφές για τα τέσσερα πεδία του <i>relCat</i> και επτά εγγραφές για τα επτά πεδία του εαυτού του.
  </p>
  <br>
Η μονάδα διαχείρισης των καταλόγων υλοποιεί μια Διεπαφή Προγραμματισμού
Εφαρμογών που αναλαμβάνει την δημιουργία, ενημέρωση και αναζήτηση των
καταλόγων της βάσης.<br>
  <br>
  <br>
  <font size="4">CFM_Create()</font><br>
  <br>
  int CFM_Create(void)<br>
  <br>
  <div style="text-align: justify;">
Η συνάρτηση αυτή δημιουργεί και αρχικοποιεί τους πίνακες relCat και
attrCat οι οποίοι αρχικά περιέχουν μόνο τις πληροφορίες για τον εαυτό
τους.<br>
  </div>
  <br>
  <br>
  <font size="4">CFM_AddRel()</font><br>
  <br>
  int CFM_AddRel(<br>
  &nbsp;&nbsp; &nbsp;relDesc rel, &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* η εγγραφή της σχέσης */<br>
  &nbsp;&nbsp; &nbsp;attrDesc* attrs&nbsp;&nbsp; /* οι εγγραφές των πεδίων της σχέσης */<br>
  )<br>
  <br>
  <div style="text-align: justify;">
Η συνάρτηση αυτή εισάγει στους καταλόγους της βάσης, τις εγγραφές μιας
νέας σχέσης. Επιστρέφει UTE_OK αν η εισαγωγή έγινε επιτυχώς ειδ'
αλλοιώς κάποιων κωδικό σφάλματος.&nbsp;<br>
  </div>
  <br>
  <br>
  <font size="4">CFM_DeleteRel()<br>
  </font><br>
  int CFM_DeleteRel(<br>
  &nbsp;&nbsp; &nbsp;char* relName&nbsp; /* το όνομα της σχέσης */<br>
  )<br>
  <br>
  <div style="text-align: justify;">
Η συνάρτηση αυτή διαγράφει από τους καταλόγους όλες τις πληροφορίες της
σχέσης με όνομα relName. Επιστρέφει UTE_OK αν η διαγραφή έγινε επιτυχώς
ειδ' αλλοιώς κάποιων κωδικό σφάλματος.<br>
  </div>
  <br>
  <br>
  <font size="4">CFM_IndexAttribute()<br>
  </font><br>
  int CFM_IndexAttribute(<br>
  &nbsp;&nbsp; &nbsp;char* relName, &nbsp;&nbsp; &nbsp;/* το όνομα της σχέσης */<br>
  &nbsp;&nbsp; &nbsp;char* attrName, &nbsp;&nbsp; /* το όνομα του πεδίου */<br>
  &nbsp;&nbsp;&nbsp; int indexNo&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* ο αριθμός του ευρετηρίου */<br>
  )<br>
  <br>
Η συνάρτηση αυτή ανανεώνει τα πεδία της εγγραφή του πεδίου με όνομα
attrName της σχέσης relName που έχουν σχέση με το ευρετήριο. Επιστρέφει
UTE_OK αν η ενημέρωση έγινε επιτυχώς ειδ' αλλοιώς κάποιων κωδικό
σφάλματος.<br>
  <br>
  <br>
  <font size="4">CFM_Lookup()</font><br>
  <br>
  int CFM_Lookup(<br>
  &nbsp;&nbsp; &nbsp;char* relName,&nbsp;&nbsp;&nbsp; /* το όνομα της σχέσης */<br>
  &nbsp;&nbsp; &nbsp;relDesc* rel,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* οι εγγραφή της σχέσης */<br>
  &nbsp;&nbsp; &nbsp;attrDesc** attrs&nbsp;&nbsp; /* οι εγγραφές των πεδίων της σχέσης */<br>
  )<br>
  <br>
Η συνάρτηση αυτή αναζητά τις πληροφορίες της σχέσης με όνομα relName,
και επιστρέφει στο όρισμα rel την εγγραφή της σχέσης και στο όρισμα
attrs τις εγγραφές των πεδίων της σχέσης. Επιστρέφει UTE_OK αν η
αναζήτηση έγινε επιτυχώς ειδ' αλλοιώς κάποιων κωδικό σφάλματος.&nbsp;<br>
  <br>
  <br>
  <div style="text-align: center;">
    <i><b><font size="5">SCM (Semantic Check Module)<br>
    </font></b></i>
  </div>
  <br>
  <div style="text-align: justify;">
Η μονάδα ελέγχου σημασιολογικών λαθών υλοποιεί μια Διεπαφή
Προγραμματισμού Εφαρμογών που αναλαμβάνει τον σημασιολογικό έλεγχο των
ορισμάτων των υπόλοιπων συναρτήσεων του επιπέδου αυτού. Για παράδειγμα,
η συνάρτηση SCM_create θα καλείται από την UT_create και θα πρέπει να
ελέγχει τα ορίσματα της UT_create. Ένα σημασιολογικό σφάλμα στην
UT_create για παράδειγμα, θα μπορούσε να είναι ότι ο πίνακας που
θέλουμε να δημιουργήσουμε υπάρχει.<br>
  </div>
  <br>
  <br>
  <font size="4">SCM_create()</font><br>
  <br>
  int <a name="UT_create">SCM_create</a>(int argc, char* argv[])<br>
  <div style="text-align: justify;">
Τα ορίσματά της είναι ίδια με της συνάρτησης UT_create. Επιστρέφει
UTE_OK αν ο έλεγχος έγινε με επιτυχία ειδ' αλλοιώς κάποιων κωδικό
σφάλματος.&nbsp;<br>
  </div>
  <font size="4"><br>
  <br>
  SCM_buildIndex()<br>
  </font><br>
  int <a name="UT_create">SCM_</a><a name="UT_create">buildIndex</a><a name="UT_create"></a>(int argc, char* argv[])<br>
  <div style="text-align: justify;">
    Τα ορίσματά της είναι ίδια με της συνάρτησης UT_<a name="UT_create">buildIndex</a><a name="UT_create"></a>. Επιστρέφει UTE_OK αν ο έλεγχος έγινε με επιτυχία ειδ' αλλοιώς κάποιων κωδικό σφάλματος.&nbsp;<br>
  </div>
  <br>
  <br>
  <font size="4">SCM_destroy()</font><br>
  <br>
  int <a name="UT_create">SCM_</a><a name="UT_create">destroy</a><a name="UT_create"></a>(int argc, char* argv[])<br>
  <div style="text-align: justify;">
    Τα ορίσματά της είναι ίδια με της συνάρτησης UT_<a name="UT_create">destroy</a>. Επιστρέφει UTE_OK αν ο έλεγχος έγινε με επιτυχία ειδ' αλλοιώς κάποιων κωδικό σφάλματος.<br>
  </div>
  <br>
  <br>
  <font size="4">SCM_print()</font><br>
  <br>
  int <a name="UT_create">SCM_</a><a name="UT_create">print</a><a name="UT_create"></a>(int argc, char* argv[])<br>
  <div style="text-align: justify;">
Τα ορίσματά της είναι ίδια με της συνάρτησης UT_print. Επιστρέφει
UTE_OK αν ο έλεγχος έγινε με επιτυχία ειδ' αλλοιώς κάποιων κωδικό
σφάλματος.<br>
  </div>
  <br>
  <br>
  <font size="4">SCM_insert()</font><br>
  <br>
  int <a name="UT_create">SCM_</a><a name="UT_create">insert</a><a name="UT_create"></a>(int argc, char* argv[])<br>
  <div style="text-align: justify;">
Τα ορίσματά της είναι ίδια με της συνάρτησης DM_insert. Επιστρέφει
UTE_OK αν ο έλεγχος έγινε με επιτυχία ειδ' αλλοιώς κάποιων κωδικό
σφάλματος.<br>
  </div>
  <br>
  <br>
  <font size="4">SCM_delete()</font><br>
  <br>
  int <a name="UT_create">SCM_</a><a name="UT_create">delete</a><a name="UT_create"></a>(int argc, char* argv[])<br>
  <div style="text-align: justify;">
Τα ορίσματά της είναι ίδια με της συνάρτησης DM_delete. Επιστρέφει
UTE_OK αν ο έλεγχος έγινε με επιτυχία ειδ' αλλοιώς κάποιων κωδικό
σφάλματος.<br>
  </div>
  <br>
  <br>
  <font size="4">SCM_select()</font><br>
  <br>
  int <a name="UT_create">SCM_</a><a name="UT_create">select</a><a name="UT_create"></a>(int argc, char* argv[])<br>
  <div style="text-align: justify;">
Τα ορίσματά της είναι ίδια με της συνάρτησης DM_select. Επιστρέφει
UTE_OK αν ο έλεγχος έγινε με επιτυχία ειδ' αλλοιώς κάποιων κωδικό
σφάλματος.<br>
  </div>
  <br>
  <br>
  <font size="4">SCM_join()</font><br>
  <br>
  int <a name="UT_create">SCM_</a><a name="UT_create">join</a><a name="UT_create"></a>(int argc, char* argv[])<br>
  <div style="text-align: justify;">
Τα ορίσματά της είναι ίδια με της συνάρτησης DM_join. Επιστρέφει UTE_OK
αν ο έλεγχος έγινε με επιτυχία ειδ' αλλοιώς κάποιων κωδικό σφάλματος.<br>
  </div>
  <br>
  <br>
  <br>
  <div style="text-align: center;">
    <font size="5"><i><b>UT (Utilities)<br>
    </b></i></font>
  </div>
  <br>
  <div style="text-align: justify;">
Οι βοηθητικές συναρτήσεις δεδομένων υλοποιούν εντολές όπως η δημιουργία
και καταστροφή σχέσεων, η παροχή πληροφοριών για τους καταλόγους της
βάσης, κλπ. Πρόκειται για συναρτήσεις οι οποίες καλούνται απευθείας από
τον συμβολομεταφραστή, ανάλογα με τις εντολές που εισάγει ο χρήστης.
Ειδικότερα οι βοηθητικές συναρτήσεις δεδομένων είναι οι εξής:<br>
  </div>
  <br>
  <font size="4">UT_create()</font><br>
  <br>
  int <a name="UT_create">UT_create</a>(int argc, char* argv[])<br>
  &nbsp;&nbsp; &nbsp;argv[0]="create"<br>
  &nbsp;&nbsp; &nbsp;argv[1]=όνομα-σχέσης<br>
  &nbsp;&nbsp; &nbsp;argv[2]=όνομα-πεδίου-1<br>
  &nbsp;&nbsp; &nbsp;argv[3]=φορμάτ-πεδίου-1<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.<br>
  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.<br>
  &nbsp;&nbsp; &nbsp;argv[argc-2]=όνομα-πεδίου-Ν<br>
  &nbsp;&nbsp; &nbsp;argv[argc-1]=φορμάτ-πεδίου-Ν<br>
  &nbsp;&nbsp; &nbsp;argv[argc]=NULL<br>
  <br>
  <br>
  <div style="text-align: justify;">
    Η συνάρτηση αυτή καλείται όταν ο χρήστης πληκτρολογήσει μια εντολή <i>CREATE</i>. Για τη δημιουργία της νέας σχέσης, η υλοποίησή σας θα πρέπει να χρησιμοποιεί την συνάρτηση <i>HF_CreateFile</i>. Επιπλέον θα πρέπει να ενημερώνει τους καταλόγους (σχέσεις <i>relCat</i> και <i>attrCat</i>, κλπ) της βάσης. Δηλαδή, θα πρέπει να εισάγει μία εγγραφή στη σχέση <i>relCat</i>, η οποία να περιγράφει τα χαρακτηριστικά της νέας σχέσης. Επιπρόσθετα, θα πρέπει να εισάγει στη σχέση <i>attrCat</i> τις αντίστοιχες εγγραφές που θα περιγράφουν ένα-ένα τα γνωρίσματα της νέας σχέσης.<br>
  </div>
  <br>
  <font size="4"><br>
  UT_buildIndex()</font><br>
  <br>
  int <a name="UT_buildindex">UT_buildindex</a>(int argc, char* argv[])<br>
  &nbsp;&nbsp; &nbsp;argv[0]="buildindex"<br>
  &nbsp;&nbsp; &nbsp;argv[1]=όνομα-σχέσης<br>
  &nbsp;&nbsp; &nbsp;argv[2]=όνομα-πεδίου<br>
  &nbsp;&nbsp; &nbsp;argv[3]=NULL<br>
  <br>
  <br>
  <div style="text-align: justify;">
    Η συνάρτηση αυτή καλείται όταν ο χρήστης πληκτρολογήσει μια εντολή <i>BUILDINDEX</i>. Η υλοποίηση της εντολής αυτής θα πρέπει να δημιουργεί το ευρετήριο χρησιμοποιώντας την συνάρτηση <i>AM_CreateIndex</i> και να ενημερώνει κατάλληλα τους καταλόγους της βάσης.<br>
  </div>
  <br>
  <br>
  <font size="4">UT_destroy()</font><br>
  <br>
  int <a name="UT_destroy">UT_destroy</a>(int argc, char* argv[])<br>
  &nbsp;&nbsp; &nbsp;argv[0]="destroy"<br>
  &nbsp;&nbsp; &nbsp;argv[1]=όνομα-σχέσης<br>
  &nbsp;&nbsp; &nbsp;argv[2]=NULL<br>
  <br>
  <div style="text-align: justify;">
    Η συνάρτηση αυτή καλείται όταν ο χρήστης πληκτρολογήσει μια εντολή <i>DESTROY</i>. Για την υλοποίηση αυτής της εντολής θα πρέπει να χρησιμοποιήσετε τις συναρτήσεις <i>AM_DestroyIndex</i> και <i>HF_DestroyFile</i> και να ενημερώσετε κατάλληλα τους καταλόγους της βάσης.<br>
  </div>
  <br>
  <br>
  <font size="4">UT_quit()</font><br>
  <br>
  int <a name="UT_quit">UT_quit</a>(void)<br>
  <br>
  <div style="text-align: justify;">
    Η συνάρτηση αυτή καλείται όταν ο χρήστης πληκτρολογήσει την εντολή <i>QUIT</i>.
Η συνάρτηση αυτή θα πρέπει να κλείνει όλες τις τυχόν ανοικτές σχέσεις
και ευρετήρια (συμπεριλαμβανομένων και αυτών που αποτελούν τους
καταλόγους της βάσης) και στην συνέχεια να καλεί την <i>exit(1)</i>.<br>
  </div>
  <br>
  <br>
  <font size="4">UT_print();</font><br>
  <br>
  int UT_print(char* relName)<br>
  <br>
</div>
<div style="text-align: justify;"> Η συνάρτηση αυτή εκτυπώνει στην
οθόνη τις εγγραφές της σχέσης relName. Η συνάρτηση αυτή χρησιμοποιείται
από τις DM_select και DM_join σε περίπτωση που το αποτέλεσμα πρέπει να
εκτυπωθεί στην οθόνη.<br>
</div>
<br>
<h2>
  Σχολιασμός, Έλεγχος Σφαλμάτων, και Γενική Μορφοποίηση
</h2>
<div style="text-align: justify;"> Όπως πάντοτε, αναμένεται καλός
σχολιασμός του προγράμματος, και εσωτερικός (ανάμεσα στις γραμμές
κώδικα) και εξωτερικός (στην αρχή κάθε ρουτίνας). Ένας γενικός κανόνας
είναι να σχολιάζετε τα προγράμματά σας σαν να πρόκειται να τα δώσετε σε
κάποιον άλλον ο οποίος θα τα επεκτείνει και ο οποίος δεν έχει ιδέα για
το τι κάνατε όταν τα γράφατε (και δεν μπορεί ούτε να σας βρει να σας
ρωτήσει).
</div>
<p style="text-align: justify;"> Επίσης, θα πρέπει να ελέγχετε για
διάφορα σφάλματα που μπορούν να προκύψουν και να βεβαιωθείτε ότι ο
κώδικάς σας τερματίζει ομαλά, με μηνύματα που έχουν νόημα, σε όλες τις
εισόδους που ικανοποιούν την παραπάνω περιγραφή.
</p>
<hr>
<h2>
  <img src="UT_files/MISSING.html">Διαδικαστικές Λεπτομέρειες
</h2>
<div style="text-align: justify;"> Το τί ακριβώς θα παραδώσετε, πού θα
βρείτε τα αρχεία με τα οποία θα ελέγξετε τελικά το πρόγραμμά σας, κτλ.,
θα ανακοινωθεί σύντομα.
</div>
<p style="text-align: justify;"> Τα προγράμματά σας θα πρέπει να
δουλεύουν στα μηχανήματα του τμήματος (είτε στα sun (Linux) είτε στα pc
(Windows)) ώστε να μπορούν να ελεγχθούν. Ακόμη και αν δουλέψετε σε
δικούς σας υπολογιστές θα πρέπει να βεβαιωθείτε ότι το τελικό
αποτέλεσμα δουλεύει και εδώ τοπικά. Η έκδοση της C που θα
χρησιμοποιήσετε πρέπει να έχει ακέραιους των 4 bytes και να επιτρέπει
αλλαγή ερμηνείας τύπου δεδομένων (type casting).
</p>
<hr size="2"><br style="font-family: Verdana;"></body></html>